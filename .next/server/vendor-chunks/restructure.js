/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/restructure";
exports.ids = ["vendor-chunks/restructure"];
exports.modules = {

/***/ "(ssr)/./node_modules/restructure/dist/main.cjs":
/*!************************************************!*\
  !*** ./node_modules/restructure/dist/main.cjs ***!
  \************************************************/
/***/ ((module) => {

eval("function $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      }\n    });\n  });\n\n  return dest;\n}\n\n$parcel$export(module.exports, \"EncodeStream\", () => $1ed46182c1410e1d$export$9b4f661deaa36c3e);\n$parcel$export(module.exports, \"DecodeStream\", () => $8ae20583b93e4933$export$c18b354bac7948e9);\n$parcel$export(module.exports, \"Array\", () => $8ea28a08eae2a116$export$c4be6576ca6fe4aa);\n$parcel$export(module.exports, \"LazyArray\", () => $444f112d3cbc7e9f$export$5576c026028d4983);\n$parcel$export(module.exports, \"Bitfield\", () => $3def237a34a226b5$export$96b43b8a49f688ea);\n$parcel$export(module.exports, \"Boolean\", () => $8415e91bb83faf74$export$ff887cefee4d61ec);\n$parcel$export(module.exports, \"Buffer\", () => $08d28604119af47e$export$7d22a0eea6656474);\n$parcel$export(module.exports, \"Enum\", () => $070ce31ea947467f$export$deb82508dd66d288);\n$parcel$export(module.exports, \"Optional\", () => $80703542fcfb6ff0$export$7acb7b24c478f9c6);\n$parcel$export(module.exports, \"Reserved\", () => $f4fd49878232508a$export$da9b5fe187a9aa1);\n$parcel$export(module.exports, \"String\", () => $d8705cd4022e7dcf$export$89b8e0fa65f6a914);\n$parcel$export(module.exports, \"Struct\", () => $aa8b66bae6abe658$export$eabc71f011df675a);\n$parcel$export(module.exports, \"VersionedStruct\", () => $fcb208a95f6d048b$export$95a8b60f4da7dec8);\n// Node back-compat.\nconst $8ae20583b93e4933$var$ENCODING_MAPPING = {\n    utf16le: \"utf-16le\",\n    ucs2: \"utf-16le\",\n    utf16be: \"utf-16be\"\n};\nclass $8ae20583b93e4933$export$c18b354bac7948e9 {\n    constructor(buffer){\n        this.buffer = buffer;\n        this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n        this.pos = 0;\n        this.length = this.buffer.length;\n    }\n    readString(length, encoding = \"ascii\") {\n        encoding = $8ae20583b93e4933$var$ENCODING_MAPPING[encoding] || encoding;\n        let buf = this.readBuffer(length);\n        try {\n            let decoder = new TextDecoder(encoding);\n            return decoder.decode(buf);\n        } catch (err) {\n            return buf;\n        }\n    }\n    readBuffer(length) {\n        return this.buffer.slice(this.pos, this.pos += length);\n    }\n    readUInt24BE() {\n        return (this.readUInt16BE() << 8) + this.readUInt8();\n    }\n    readUInt24LE() {\n        return this.readUInt16LE() + (this.readUInt8() << 16);\n    }\n    readInt24BE() {\n        return (this.readInt16BE() << 8) + this.readUInt8();\n    }\n    readInt24LE() {\n        return this.readUInt16LE() + (this.readInt8() << 16);\n    }\n}\n$8ae20583b93e4933$export$c18b354bac7948e9.TYPES = {\n    UInt8: 1,\n    UInt16: 2,\n    UInt24: 3,\n    UInt32: 4,\n    Int8: 1,\n    Int16: 2,\n    Int24: 3,\n    Int32: 4,\n    Float: 4,\n    Double: 8\n};\nfor (let key of Object.getOwnPropertyNames(DataView.prototype))if (key.slice(0, 3) === \"get\") {\n    let type = key.slice(3).replace(\"Ui\", \"UI\");\n    if (type === \"Float32\") type = \"Float\";\n    else if (type === \"Float64\") type = \"Double\";\n    let bytes = $8ae20583b93e4933$export$c18b354bac7948e9.TYPES[type];\n    $8ae20583b93e4933$export$c18b354bac7948e9.prototype[\"read\" + type + (bytes === 1 ? \"\" : \"BE\")] = function() {\n        const ret = this.view[key](this.pos, false);\n        this.pos += bytes;\n        return ret;\n    };\n    if (bytes !== 1) $8ae20583b93e4933$export$c18b354bac7948e9.prototype[\"read\" + type + \"LE\"] = function() {\n        const ret = this.view[key](this.pos, true);\n        this.pos += bytes;\n        return ret;\n    };\n}\n\n\nconst $1ed46182c1410e1d$var$textEncoder = new TextEncoder();\nconst $1ed46182c1410e1d$var$isBigEndian = new Uint8Array(new Uint16Array([\n    0x1234\n]).buffer)[0] == 0x12;\nclass $1ed46182c1410e1d$export$9b4f661deaa36c3e {\n    constructor(buffer){\n        this.buffer = buffer;\n        this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);\n        this.pos = 0;\n    }\n    writeBuffer(buffer) {\n        this.buffer.set(buffer, this.pos);\n        this.pos += buffer.length;\n    }\n    writeString(string, encoding = \"ascii\") {\n        let buf;\n        switch(encoding){\n            case \"utf16le\":\n            case \"utf16-le\":\n            case \"ucs2\":\n                buf = $1ed46182c1410e1d$var$stringToUtf16(string, $1ed46182c1410e1d$var$isBigEndian);\n                break;\n            case \"utf16be\":\n            case \"utf16-be\":\n                buf = $1ed46182c1410e1d$var$stringToUtf16(string, !$1ed46182c1410e1d$var$isBigEndian);\n                break;\n            case \"utf8\":\n                buf = $1ed46182c1410e1d$var$textEncoder.encode(string);\n                break;\n            case \"ascii\":\n                buf = $1ed46182c1410e1d$var$stringToAscii(string);\n                break;\n            default:\n                throw new Error(`Unsupported encoding: ${encoding}`);\n        }\n        this.writeBuffer(buf);\n    }\n    writeUInt24BE(val) {\n        this.buffer[this.pos++] = val >>> 16 & 0xff;\n        this.buffer[this.pos++] = val >>> 8 & 0xff;\n        this.buffer[this.pos++] = val & 0xff;\n    }\n    writeUInt24LE(val) {\n        this.buffer[this.pos++] = val & 0xff;\n        this.buffer[this.pos++] = val >>> 8 & 0xff;\n        this.buffer[this.pos++] = val >>> 16 & 0xff;\n    }\n    writeInt24BE(val) {\n        if (val >= 0) this.writeUInt24BE(val);\n        else this.writeUInt24BE(val + 0xffffff + 1);\n    }\n    writeInt24LE(val) {\n        if (val >= 0) this.writeUInt24LE(val);\n        else this.writeUInt24LE(val + 0xffffff + 1);\n    }\n    fill(val, length) {\n        if (length < this.buffer.length) {\n            this.buffer.fill(val, this.pos, this.pos + length);\n            this.pos += length;\n        } else {\n            const buf = new Uint8Array(length);\n            buf.fill(val);\n            this.writeBuffer(buf);\n        }\n    }\n}\nfunction $1ed46182c1410e1d$var$stringToUtf16(string, swap) {\n    let buf = new Uint16Array(string.length);\n    for(let i = 0; i < string.length; i++){\n        let code = string.charCodeAt(i);\n        if (swap) code = code >> 8 | (code & 0xff) << 8;\n        buf[i] = code;\n    }\n    return new Uint8Array(buf.buffer);\n}\nfunction $1ed46182c1410e1d$var$stringToAscii(string) {\n    let buf = new Uint8Array(string.length);\n    for(let i = 0; i < string.length; i++)// Match node.js behavior - encoding allows 8-bit rather than 7-bit.\n    buf[i] = string.charCodeAt(i);\n    return buf;\n}\nfor (let key of Object.getOwnPropertyNames(DataView.prototype))if (key.slice(0, 3) === \"set\") {\n    let type = key.slice(3).replace(\"Ui\", \"UI\");\n    if (type === \"Float32\") type = \"Float\";\n    else if (type === \"Float64\") type = \"Double\";\n    let bytes = (0, $8ae20583b93e4933$export$c18b354bac7948e9).TYPES[type];\n    $1ed46182c1410e1d$export$9b4f661deaa36c3e.prototype[\"write\" + type + (bytes === 1 ? \"\" : \"BE\")] = function(value) {\n        this.view[key](this.pos, value, false);\n        this.pos += bytes;\n    };\n    if (bytes !== 1) $1ed46182c1410e1d$export$9b4f661deaa36c3e.prototype[\"write\" + type + \"LE\"] = function(value) {\n        this.view[key](this.pos, value, true);\n        this.pos += bytes;\n    };\n}\n\n\n\n\n\nclass $8d21f7fa58802901$export$ef88aa0d34c34520 {\n    fromBuffer(buffer) {\n        let stream = new (0, $8ae20583b93e4933$export$c18b354bac7948e9)(buffer);\n        return this.decode(stream);\n    }\n    toBuffer(value) {\n        let size = this.size(value);\n        let buffer = new Uint8Array(size);\n        let stream = new (0, $1ed46182c1410e1d$export$9b4f661deaa36c3e)(buffer);\n        this.encode(stream, value);\n        return buffer;\n    }\n}\n\n\nvar $af65abf7bf65ac42$exports = {};\n\n$parcel$export($af65abf7bf65ac42$exports, \"Number\", () => $af65abf7bf65ac42$export$fffa67e515d04022);\n$parcel$export($af65abf7bf65ac42$exports, \"uint8\", () => $af65abf7bf65ac42$export$52e103c63c4e68cf);\n$parcel$export($af65abf7bf65ac42$exports, \"uint16be\", () => $af65abf7bf65ac42$export$60dfe43c8297a8f8);\n$parcel$export($af65abf7bf65ac42$exports, \"uint16\", () => $af65abf7bf65ac42$export$56bd24b5a3ee8456);\n$parcel$export($af65abf7bf65ac42$exports, \"uint16le\", () => $af65abf7bf65ac42$export$b92d76f0ca6d1789);\n$parcel$export($af65abf7bf65ac42$exports, \"uint24be\", () => $af65abf7bf65ac42$export$255f45171f96b50c);\n$parcel$export($af65abf7bf65ac42$exports, \"uint24\", () => $af65abf7bf65ac42$export$1925298fbd719b21);\n$parcel$export($af65abf7bf65ac42$exports, \"uint24le\", () => $af65abf7bf65ac42$export$758e1dafc8dc7271);\n$parcel$export($af65abf7bf65ac42$exports, \"uint32be\", () => $af65abf7bf65ac42$export$74c16dba6c885532);\n$parcel$export($af65abf7bf65ac42$exports, \"uint32\", () => $af65abf7bf65ac42$export$de9ffb9418dd7d0d);\n$parcel$export($af65abf7bf65ac42$exports, \"uint32le\", () => $af65abf7bf65ac42$export$5f744bb30a534bc9);\n$parcel$export($af65abf7bf65ac42$exports, \"int8\", () => $af65abf7bf65ac42$export$5984f25eab09961f);\n$parcel$export($af65abf7bf65ac42$exports, \"int16be\", () => $af65abf7bf65ac42$export$198ae7d10d26a900);\n$parcel$export($af65abf7bf65ac42$exports, \"int16\", () => $af65abf7bf65ac42$export$c35c15c7caeff2b6);\n$parcel$export($af65abf7bf65ac42$exports, \"int16le\", () => $af65abf7bf65ac42$export$399cc4b7169e5aed);\n$parcel$export($af65abf7bf65ac42$exports, \"int24be\", () => $af65abf7bf65ac42$export$3676d1f71eca2ec0);\n$parcel$export($af65abf7bf65ac42$exports, \"int24\", () => $af65abf7bf65ac42$export$73f695d681ac61f9);\n$parcel$export($af65abf7bf65ac42$exports, \"int24le\", () => $af65abf7bf65ac42$export$671f8672dbd40a4);\n$parcel$export($af65abf7bf65ac42$exports, \"int32be\", () => $af65abf7bf65ac42$export$78a2ac3d09dd42d5);\n$parcel$export($af65abf7bf65ac42$exports, \"int32\", () => $af65abf7bf65ac42$export$1d95835383bb05a);\n$parcel$export($af65abf7bf65ac42$exports, \"int32le\", () => $af65abf7bf65ac42$export$5ec1f146e759329a);\n$parcel$export($af65abf7bf65ac42$exports, \"floatbe\", () => $af65abf7bf65ac42$export$92b5c14c6abb5c97);\n$parcel$export($af65abf7bf65ac42$exports, \"float\", () => $af65abf7bf65ac42$export$6b5cd3983e3ee5ab);\n$parcel$export($af65abf7bf65ac42$exports, \"floatle\", () => $af65abf7bf65ac42$export$6d20592bc4cb19d9);\n$parcel$export($af65abf7bf65ac42$exports, \"doublebe\", () => $af65abf7bf65ac42$export$e50b9e97e4d43631);\n$parcel$export($af65abf7bf65ac42$exports, \"double\", () => $af65abf7bf65ac42$export$7b3cbda67be88f5f);\n$parcel$export($af65abf7bf65ac42$exports, \"doublele\", () => $af65abf7bf65ac42$export$6f53315aa512b751);\n$parcel$export($af65abf7bf65ac42$exports, \"Fixed\", () => $af65abf7bf65ac42$export$13475bbd2a37a9b4);\n$parcel$export($af65abf7bf65ac42$exports, \"fixed16be\", () => $af65abf7bf65ac42$export$f87b441e6bd90278);\n$parcel$export($af65abf7bf65ac42$exports, \"fixed16\", () => $af65abf7bf65ac42$export$a3abada75ef55921);\n$parcel$export($af65abf7bf65ac42$exports, \"fixed16le\", () => $af65abf7bf65ac42$export$3752a2886837dc22);\n$parcel$export($af65abf7bf65ac42$exports, \"fixed32be\", () => $af65abf7bf65ac42$export$dd71d8d9bc792632);\n$parcel$export($af65abf7bf65ac42$exports, \"fixed32\", () => $af65abf7bf65ac42$export$e913265d48471f2d);\n$parcel$export($af65abf7bf65ac42$exports, \"fixed32le\", () => $af65abf7bf65ac42$export$7fc47db6a5fc8223);\n\n\nclass $af65abf7bf65ac42$export$fffa67e515d04022 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {\n    constructor(type, endian = \"BE\"){\n        super();\n        this.type = type;\n        this.endian = endian;\n        this.fn = this.type;\n        if (this.type[this.type.length - 1] !== \"8\") this.fn += this.endian;\n    }\n    size() {\n        return (0, $8ae20583b93e4933$export$c18b354bac7948e9).TYPES[this.type];\n    }\n    decode(stream) {\n        return stream[`read${this.fn}`]();\n    }\n    encode(stream, val) {\n        return stream[`write${this.fn}`](val);\n    }\n}\nconst $af65abf7bf65ac42$export$52e103c63c4e68cf = new $af65abf7bf65ac42$export$fffa67e515d04022(\"UInt8\");\nconst $af65abf7bf65ac42$export$60dfe43c8297a8f8 = new $af65abf7bf65ac42$export$fffa67e515d04022(\"UInt16\", \"BE\");\nconst $af65abf7bf65ac42$export$56bd24b5a3ee8456 = $af65abf7bf65ac42$export$60dfe43c8297a8f8;\nconst $af65abf7bf65ac42$export$b92d76f0ca6d1789 = new $af65abf7bf65ac42$export$fffa67e515d04022(\"UInt16\", \"LE\");\nconst $af65abf7bf65ac42$export$255f45171f96b50c = new $af65abf7bf65ac42$export$fffa67e515d04022(\"UInt24\", \"BE\");\nconst $af65abf7bf65ac42$export$1925298fbd719b21 = $af65abf7bf65ac42$export$255f45171f96b50c;\nconst $af65abf7bf65ac42$export$758e1dafc8dc7271 = new $af65abf7bf65ac42$export$fffa67e515d04022(\"UInt24\", \"LE\");\nconst $af65abf7bf65ac42$export$74c16dba6c885532 = new $af65abf7bf65ac42$export$fffa67e515d04022(\"UInt32\", \"BE\");\nconst $af65abf7bf65ac42$export$de9ffb9418dd7d0d = $af65abf7bf65ac42$export$74c16dba6c885532;\nconst $af65abf7bf65ac42$export$5f744bb30a534bc9 = new $af65abf7bf65ac42$export$fffa67e515d04022(\"UInt32\", \"LE\");\nconst $af65abf7bf65ac42$export$5984f25eab09961f = new $af65abf7bf65ac42$export$fffa67e515d04022(\"Int8\");\nconst $af65abf7bf65ac42$export$198ae7d10d26a900 = new $af65abf7bf65ac42$export$fffa67e515d04022(\"Int16\", \"BE\");\nconst $af65abf7bf65ac42$export$c35c15c7caeff2b6 = $af65abf7bf65ac42$export$198ae7d10d26a900;\nconst $af65abf7bf65ac42$export$399cc4b7169e5aed = new $af65abf7bf65ac42$export$fffa67e515d04022(\"Int16\", \"LE\");\nconst $af65abf7bf65ac42$export$3676d1f71eca2ec0 = new $af65abf7bf65ac42$export$fffa67e515d04022(\"Int24\", \"BE\");\nconst $af65abf7bf65ac42$export$73f695d681ac61f9 = $af65abf7bf65ac42$export$3676d1f71eca2ec0;\nconst $af65abf7bf65ac42$export$671f8672dbd40a4 = new $af65abf7bf65ac42$export$fffa67e515d04022(\"Int24\", \"LE\");\nconst $af65abf7bf65ac42$export$78a2ac3d09dd42d5 = new $af65abf7bf65ac42$export$fffa67e515d04022(\"Int32\", \"BE\");\nconst $af65abf7bf65ac42$export$1d95835383bb05a = $af65abf7bf65ac42$export$78a2ac3d09dd42d5;\nconst $af65abf7bf65ac42$export$5ec1f146e759329a = new $af65abf7bf65ac42$export$fffa67e515d04022(\"Int32\", \"LE\");\nconst $af65abf7bf65ac42$export$92b5c14c6abb5c97 = new $af65abf7bf65ac42$export$fffa67e515d04022(\"Float\", \"BE\");\nconst $af65abf7bf65ac42$export$6b5cd3983e3ee5ab = $af65abf7bf65ac42$export$92b5c14c6abb5c97;\nconst $af65abf7bf65ac42$export$6d20592bc4cb19d9 = new $af65abf7bf65ac42$export$fffa67e515d04022(\"Float\", \"LE\");\nconst $af65abf7bf65ac42$export$e50b9e97e4d43631 = new $af65abf7bf65ac42$export$fffa67e515d04022(\"Double\", \"BE\");\nconst $af65abf7bf65ac42$export$7b3cbda67be88f5f = $af65abf7bf65ac42$export$e50b9e97e4d43631;\nconst $af65abf7bf65ac42$export$6f53315aa512b751 = new $af65abf7bf65ac42$export$fffa67e515d04022(\"Double\", \"LE\");\nclass $af65abf7bf65ac42$export$13475bbd2a37a9b4 extends $af65abf7bf65ac42$export$fffa67e515d04022 {\n    constructor(size, endian, fracBits = size >> 1){\n        super(`Int${size}`, endian);\n        this._point = 1 << fracBits;\n    }\n    decode(stream) {\n        return super.decode(stream) / this._point;\n    }\n    encode(stream, val) {\n        return super.encode(stream, val * this._point | 0);\n    }\n}\nconst $af65abf7bf65ac42$export$f87b441e6bd90278 = new $af65abf7bf65ac42$export$13475bbd2a37a9b4(16, \"BE\");\nconst $af65abf7bf65ac42$export$a3abada75ef55921 = $af65abf7bf65ac42$export$f87b441e6bd90278;\nconst $af65abf7bf65ac42$export$3752a2886837dc22 = new $af65abf7bf65ac42$export$13475bbd2a37a9b4(16, \"LE\");\nconst $af65abf7bf65ac42$export$dd71d8d9bc792632 = new $af65abf7bf65ac42$export$13475bbd2a37a9b4(32, \"BE\");\nconst $af65abf7bf65ac42$export$e913265d48471f2d = $af65abf7bf65ac42$export$dd71d8d9bc792632;\nconst $af65abf7bf65ac42$export$7fc47db6a5fc8223 = new $af65abf7bf65ac42$export$13475bbd2a37a9b4(32, \"LE\");\n\n\nvar $4559ecf940edc78d$exports = {};\n\n$parcel$export($4559ecf940edc78d$exports, \"resolveLength\", () => $4559ecf940edc78d$export$83b6dc3503c1fda6);\n$parcel$export($4559ecf940edc78d$exports, \"PropertyDescriptor\", () => $4559ecf940edc78d$export$41705b1d644e0f14);\n\nfunction $4559ecf940edc78d$export$83b6dc3503c1fda6(length, stream, parent) {\n    let res;\n    if (typeof length === \"number\") res = length;\n    else if (typeof length === \"function\") res = length.call(parent, parent);\n    else if (parent && typeof length === \"string\") res = parent[length];\n    else if (stream && length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) res = length.decode(stream);\n    if (isNaN(res)) throw new Error(\"Not a fixed size\");\n    return res;\n}\nclass $4559ecf940edc78d$export$41705b1d644e0f14 {\n    constructor(opts = {}){\n        this.enumerable = true;\n        this.configurable = true;\n        for(let key in opts){\n            const val = opts[key];\n            this[key] = val;\n        }\n    }\n}\n\n\nclass $8ea28a08eae2a116$export$c4be6576ca6fe4aa extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {\n    constructor(type, length, lengthType = \"count\"){\n        super();\n        this.type = type;\n        this.length = length;\n        this.lengthType = lengthType;\n    }\n    decode(stream, parent) {\n        let length;\n        const { pos: pos  } = stream;\n        const res = [];\n        let ctx = parent;\n        if (this.length != null) length = $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, stream, parent);\n        if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) {\n            // define hidden properties\n            Object.defineProperties(res, {\n                parent: {\n                    value: parent\n                },\n                _startOffset: {\n                    value: pos\n                },\n                _currentOffset: {\n                    value: 0,\n                    writable: true\n                },\n                _length: {\n                    value: length\n                }\n            });\n            ctx = res;\n        }\n        if (length == null || this.lengthType === \"bytes\") {\n            const target = length != null ? stream.pos + length : (parent != null ? parent._length : undefined) ? parent._startOffset + parent._length : stream.length;\n            while(stream.pos < target)res.push(this.type.decode(stream, ctx));\n        } else for(let i = 0, end = length; i < end; i++)res.push(this.type.decode(stream, ctx));\n        return res;\n    }\n    size(array, ctx, includePointers = true) {\n        if (!array) return this.type.size(null, ctx) * $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, null, ctx);\n        let size = 0;\n        if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) {\n            size += this.length.size();\n            ctx = {\n                parent: ctx,\n                pointerSize: 0\n            };\n        }\n        for (let item of array)size += this.type.size(item, ctx);\n        if (ctx && includePointers && this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) size += ctx.pointerSize;\n        return size;\n    }\n    encode(stream, array, parent) {\n        let ctx = parent;\n        if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) {\n            ctx = {\n                pointers: [],\n                startOffset: stream.pos,\n                parent: parent\n            };\n            ctx.pointerOffset = stream.pos + this.size(array, ctx, false);\n            this.length.encode(stream, array.length);\n        }\n        for (let item of array)this.type.encode(stream, item, ctx);\n        if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) {\n            let i = 0;\n            while(i < ctx.pointers.length){\n                const ptr = ctx.pointers[i++];\n                ptr.type.encode(stream, ptr.val, ptr.parent);\n            }\n        }\n    }\n}\n\n\n\n\n\nclass $444f112d3cbc7e9f$export$5576c026028d4983 extends (0, $8ea28a08eae2a116$export$c4be6576ca6fe4aa) {\n    decode(stream, parent) {\n        const { pos: pos  } = stream;\n        const length = $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, stream, parent);\n        if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) parent = {\n            parent: parent,\n            _startOffset: pos,\n            _currentOffset: 0,\n            _length: length\n        };\n        const res = new $444f112d3cbc7e9f$var$LazyArrayValue(this.type, length, stream, parent);\n        stream.pos += length * this.type.size(null, parent);\n        return res;\n    }\n    size(val, ctx) {\n        if (val instanceof $444f112d3cbc7e9f$var$LazyArrayValue) val = val.toArray();\n        return super.size(val, ctx);\n    }\n    encode(stream, val, ctx) {\n        if (val instanceof $444f112d3cbc7e9f$var$LazyArrayValue) val = val.toArray();\n        return super.encode(stream, val, ctx);\n    }\n}\nclass $444f112d3cbc7e9f$var$LazyArrayValue {\n    constructor(type, length, stream, ctx){\n        this.type = type;\n        this.length = length;\n        this.stream = stream;\n        this.ctx = ctx;\n        this.base = this.stream.pos;\n        this.items = [];\n    }\n    get(index) {\n        if (index < 0 || index >= this.length) return undefined;\n        if (this.items[index] == null) {\n            const { pos: pos  } = this.stream;\n            this.stream.pos = this.base + this.type.size(null, this.ctx) * index;\n            this.items[index] = this.type.decode(this.stream, this.ctx);\n            this.stream.pos = pos;\n        }\n        return this.items[index];\n    }\n    toArray() {\n        const result = [];\n        for(let i = 0, end = this.length; i < end; i++)result.push(this.get(i));\n        return result;\n    }\n}\n\n\n\nclass $3def237a34a226b5$export$96b43b8a49f688ea extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {\n    constructor(type, flags = []){\n        super();\n        this.type = type;\n        this.flags = flags;\n    }\n    decode(stream) {\n        const val = this.type.decode(stream);\n        const res = {};\n        for(let i = 0; i < this.flags.length; i++){\n            const flag = this.flags[i];\n            if (flag != null) res[flag] = !!(val & 1 << i);\n        }\n        return res;\n    }\n    size() {\n        return this.type.size();\n    }\n    encode(stream, keys) {\n        let val = 0;\n        for(let i = 0; i < this.flags.length; i++){\n            const flag = this.flags[i];\n            if (flag != null) {\n                if (keys[flag]) val |= 1 << i;\n            }\n        }\n        return this.type.encode(stream, val);\n    }\n}\n\n\n\nclass $8415e91bb83faf74$export$ff887cefee4d61ec extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {\n    constructor(type){\n        super();\n        this.type = type;\n    }\n    decode(stream, parent) {\n        return !!this.type.decode(stream, parent);\n    }\n    size(val, parent) {\n        return this.type.size(val, parent);\n    }\n    encode(stream, val, parent) {\n        return this.type.encode(stream, +val, parent);\n    }\n}\n\n\n\n\n\nclass $08d28604119af47e$export$7d22a0eea6656474 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {\n    constructor(length){\n        super();\n        this.length = length;\n    }\n    decode(stream, parent) {\n        const length = $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, stream, parent);\n        return stream.readBuffer(length);\n    }\n    size(val, parent) {\n        if (!val) return $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, null, parent);\n        let len = val.length;\n        if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) len += this.length.size();\n        return len;\n    }\n    encode(stream, buf, parent) {\n        if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) this.length.encode(stream, buf.length);\n        return stream.writeBuffer(buf);\n    }\n}\n\n\n\nclass $070ce31ea947467f$export$deb82508dd66d288 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {\n    constructor(type, options = []){\n        super();\n        this.type = type;\n        this.options = options;\n    }\n    decode(stream) {\n        const index = this.type.decode(stream);\n        return this.options[index] || index;\n    }\n    size() {\n        return this.type.size();\n    }\n    encode(stream, val) {\n        const index = this.options.indexOf(val);\n        if (index === -1) throw new Error(`Unknown option in enum: ${val}`);\n        return this.type.encode(stream, index);\n    }\n}\n\n\n\nclass $80703542fcfb6ff0$export$7acb7b24c478f9c6 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {\n    constructor(type, condition = true){\n        super();\n        this.type = type;\n        this.condition = condition;\n    }\n    decode(stream, parent) {\n        let { condition: condition  } = this;\n        if (typeof condition === \"function\") condition = condition.call(parent, parent);\n        if (condition) return this.type.decode(stream, parent);\n    }\n    size(val, parent) {\n        let { condition: condition  } = this;\n        if (typeof condition === \"function\") condition = condition.call(parent, parent);\n        if (condition) return this.type.size(val, parent);\n        else return 0;\n    }\n    encode(stream, val, parent) {\n        let { condition: condition  } = this;\n        if (typeof condition === \"function\") condition = condition.call(parent, parent);\n        if (condition) return this.type.encode(stream, val, parent);\n    }\n}\n\n\n\n\nclass $f4fd49878232508a$export$da9b5fe187a9aa1 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {\n    constructor(type, count = 1){\n        super();\n        this.type = type;\n        this.count = count;\n    }\n    decode(stream, parent) {\n        stream.pos += this.size(null, parent);\n        return undefined;\n    }\n    size(data, parent) {\n        const count = $4559ecf940edc78d$export$83b6dc3503c1fda6(this.count, null, parent);\n        return this.type.size() * count;\n    }\n    encode(stream, val, parent) {\n        return stream.fill(0, this.size(val, parent));\n    }\n}\n\n\n\n\n\nclass $d8705cd4022e7dcf$export$89b8e0fa65f6a914 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {\n    constructor(length, encoding = \"ascii\"){\n        super();\n        this.length = length;\n        this.encoding = encoding;\n    }\n    decode(stream, parent) {\n        let length, pos;\n        if (this.length != null) length = $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, stream, parent);\n        else {\n            let buffer;\n            ({ buffer: buffer , length: length , pos: pos  } = stream);\n            while(pos < length && buffer[pos] !== 0x00)++pos;\n            length = pos - stream.pos;\n        }\n        let { encoding: encoding  } = this;\n        if (typeof encoding === \"function\") encoding = encoding.call(parent, parent) || \"ascii\";\n        const string = stream.readString(length, encoding);\n        if (this.length == null && stream.pos < stream.length) stream.pos++;\n        return string;\n    }\n    size(val, parent) {\n        // Use the defined value if no value was given\n        if (!val) return $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, null, parent);\n        let { encoding: encoding  } = this;\n        if (typeof encoding === \"function\") encoding = encoding.call(parent != null ? parent.val : undefined, parent != null ? parent.val : undefined) || \"ascii\";\n        if (encoding === \"utf16be\") encoding = \"utf16le\";\n        let size = $d8705cd4022e7dcf$var$byteLength(val, encoding);\n        if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) size += this.length.size();\n        if (this.length == null) size++;\n        return size;\n    }\n    encode(stream, val, parent) {\n        let { encoding: encoding  } = this;\n        if (typeof encoding === \"function\") encoding = encoding.call(parent != null ? parent.val : undefined, parent != null ? parent.val : undefined) || \"ascii\";\n        if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) this.length.encode(stream, $d8705cd4022e7dcf$var$byteLength(val, encoding));\n        stream.writeString(val, encoding);\n        if (this.length == null) return stream.writeUInt8(0x00);\n    }\n}\nfunction $d8705cd4022e7dcf$var$byteLength(string, encoding) {\n    switch(encoding){\n        case \"ascii\":\n            return string.length;\n        case \"utf8\":\n            let len = 0;\n            for(let i = 0; i < string.length; i++){\n                let c = string.charCodeAt(i);\n                if (c >= 0xd800 && c <= 0xdbff && i < string.length - 1) {\n                    let c2 = string.charCodeAt(++i);\n                    if ((c2 & 0xfc00) === 0xdc00) c = ((c & 0x3ff) << 10) + (c2 & 0x3ff) + 0x10000;\n                    else // unmatched surrogate.\n                    i--;\n                }\n                if ((c & 0xffffff80) === 0) len++;\n                else if ((c & 0xfffff800) === 0) len += 2;\n                else if ((c & 0xffff0000) === 0) len += 3;\n                else if ((c & 0xffe00000) === 0) len += 4;\n            }\n            return len;\n        case \"utf16le\":\n        case \"utf16-le\":\n        case \"utf16be\":\n        case \"utf16-be\":\n        case \"ucs2\":\n            return string.length * 2;\n        default:\n            throw new Error(\"Unknown encoding \" + encoding);\n    }\n}\n\n\n\n\nclass $aa8b66bae6abe658$export$eabc71f011df675a extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {\n    constructor(fields = {}){\n        super();\n        this.fields = fields;\n    }\n    decode(stream, parent, length = 0) {\n        const res = this._setup(stream, parent, length);\n        this._parseFields(stream, res, this.fields);\n        if (this.process != null) this.process.call(res, stream);\n        return res;\n    }\n    _setup(stream, parent, length) {\n        const res = {};\n        // define hidden properties\n        Object.defineProperties(res, {\n            parent: {\n                value: parent\n            },\n            _startOffset: {\n                value: stream.pos\n            },\n            _currentOffset: {\n                value: 0,\n                writable: true\n            },\n            _length: {\n                value: length\n            }\n        });\n        return res;\n    }\n    _parseFields(stream, res, fields) {\n        for(let key in fields){\n            var val;\n            const type = fields[key];\n            if (typeof type === \"function\") val = type.call(res, res);\n            else val = type.decode(stream, res);\n            if (val !== undefined) {\n                if (val instanceof $4559ecf940edc78d$export$41705b1d644e0f14) Object.defineProperty(res, key, val);\n                else res[key] = val;\n            }\n            res._currentOffset = stream.pos - res._startOffset;\n        }\n    }\n    size(val, parent, includePointers = true) {\n        if (val == null) val = {};\n        const ctx = {\n            parent: parent,\n            val: val,\n            pointerSize: 0\n        };\n        if (this.preEncode != null) this.preEncode.call(val);\n        let size = 0;\n        for(let key in this.fields){\n            const type = this.fields[key];\n            if (type.size != null) size += type.size(val[key], ctx);\n        }\n        if (includePointers) size += ctx.pointerSize;\n        return size;\n    }\n    encode(stream, val, parent) {\n        let type;\n        if (this.preEncode != null) this.preEncode.call(val, stream);\n        const ctx = {\n            pointers: [],\n            startOffset: stream.pos,\n            parent: parent,\n            val: val,\n            pointerSize: 0\n        };\n        ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n        for(let key in this.fields){\n            type = this.fields[key];\n            if (type.encode != null) type.encode(stream, val[key], ctx);\n        }\n        let i = 0;\n        while(i < ctx.pointers.length){\n            const ptr = ctx.pointers[i++];\n            ptr.type.encode(stream, ptr.val, ptr.parent);\n        }\n    }\n}\n\n\n\nconst $fcb208a95f6d048b$var$getPath = (object, pathArray)=>{\n    return pathArray.reduce((prevObj, key)=>prevObj && prevObj[key], object);\n};\nclass $fcb208a95f6d048b$export$95a8b60f4da7dec8 extends (0, $aa8b66bae6abe658$export$eabc71f011df675a) {\n    constructor(type, versions = {}){\n        super();\n        this.type = type;\n        this.versions = versions;\n        if (typeof type === \"string\") this.versionPath = type.split(\".\");\n    }\n    decode(stream, parent, length = 0) {\n        const res = this._setup(stream, parent, length);\n        if (typeof this.type === \"string\") res.version = $fcb208a95f6d048b$var$getPath(parent, this.versionPath);\n        else res.version = this.type.decode(stream);\n        if (this.versions.header) this._parseFields(stream, res, this.versions.header);\n        const fields = this.versions[res.version];\n        if (fields == null) throw new Error(`Unknown version ${res.version}`);\n        if (fields instanceof $fcb208a95f6d048b$export$95a8b60f4da7dec8) return fields.decode(stream, parent);\n        this._parseFields(stream, res, fields);\n        if (this.process != null) this.process.call(res, stream);\n        return res;\n    }\n    size(val, parent, includePointers = true) {\n        let key, type;\n        if (!val) throw new Error(\"Not a fixed size\");\n        if (this.preEncode != null) this.preEncode.call(val);\n        const ctx = {\n            parent: parent,\n            val: val,\n            pointerSize: 0\n        };\n        let size = 0;\n        if (typeof this.type !== \"string\") size += this.type.size(val.version, ctx);\n        if (this.versions.header) for(key in this.versions.header){\n            type = this.versions.header[key];\n            if (type.size != null) size += type.size(val[key], ctx);\n        }\n        const fields = this.versions[val.version];\n        if (fields == null) throw new Error(`Unknown version ${val.version}`);\n        for(key in fields){\n            type = fields[key];\n            if (type.size != null) size += type.size(val[key], ctx);\n        }\n        if (includePointers) size += ctx.pointerSize;\n        return size;\n    }\n    encode(stream, val, parent) {\n        let key, type;\n        if (this.preEncode != null) this.preEncode.call(val, stream);\n        const ctx = {\n            pointers: [],\n            startOffset: stream.pos,\n            parent: parent,\n            val: val,\n            pointerSize: 0\n        };\n        ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n        if (typeof this.type !== \"string\") this.type.encode(stream, val.version);\n        if (this.versions.header) for(key in this.versions.header){\n            type = this.versions.header[key];\n            if (type.encode != null) type.encode(stream, val[key], ctx);\n        }\n        const fields = this.versions[val.version];\n        for(key in fields){\n            type = fields[key];\n            if (type.encode != null) type.encode(stream, val[key], ctx);\n        }\n        let i = 0;\n        while(i < ctx.pointers.length){\n            const ptr = ctx.pointers[i++];\n            ptr.type.encode(stream, ptr.val, ptr.parent);\n        }\n    }\n}\n\n\n\n\nvar $92184962f8f0d5e2$exports = {};\n\n$parcel$export($92184962f8f0d5e2$exports, \"Pointer\", () => $92184962f8f0d5e2$export$b56007f12edf0c17);\n$parcel$export($92184962f8f0d5e2$exports, \"VoidPointer\", () => $92184962f8f0d5e2$export$df5cb1f3d04f5a0f);\n\n\nclass $92184962f8f0d5e2$export$b56007f12edf0c17 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {\n    constructor(offsetType, type, options = {}){\n        super();\n        this.offsetType = offsetType;\n        this.type = type;\n        this.options = options;\n        if (this.type === \"void\") this.type = null;\n        if (this.options.type == null) this.options.type = \"local\";\n        if (this.options.allowNull == null) this.options.allowNull = true;\n        if (this.options.nullValue == null) this.options.nullValue = 0;\n        if (this.options.lazy == null) this.options.lazy = false;\n        if (this.options.relativeTo) {\n            if (typeof this.options.relativeTo !== \"function\") throw new Error(\"relativeTo option must be a function\");\n            this.relativeToGetter = options.relativeTo;\n        }\n    }\n    decode(stream, ctx) {\n        const offset = this.offsetType.decode(stream, ctx);\n        // handle NULL pointers\n        if (offset === this.options.nullValue && this.options.allowNull) return null;\n        let relative;\n        switch(this.options.type){\n            case \"local\":\n                relative = ctx._startOffset;\n                break;\n            case \"immediate\":\n                relative = stream.pos - this.offsetType.size();\n                break;\n            case \"parent\":\n                relative = ctx.parent._startOffset;\n                break;\n            default:\n                var c = ctx;\n                while(c.parent)c = c.parent;\n                relative = c._startOffset || 0;\n        }\n        if (this.options.relativeTo) relative += this.relativeToGetter(ctx);\n        const ptr = offset + relative;\n        if (this.type != null) {\n            let val = null;\n            const decodeValue = ()=>{\n                if (val != null) return val;\n                const { pos: pos  } = stream;\n                stream.pos = ptr;\n                val = this.type.decode(stream, ctx);\n                stream.pos = pos;\n                return val;\n            };\n            // If this is a lazy pointer, define a getter to decode only when needed.\n            // This obviously only works when the pointer is contained by a Struct.\n            if (this.options.lazy) return new $4559ecf940edc78d$export$41705b1d644e0f14({\n                get: decodeValue\n            });\n            return decodeValue();\n        } else return ptr;\n    }\n    size(val, ctx) {\n        const parent = ctx;\n        switch(this.options.type){\n            case \"local\":\n            case \"immediate\":\n                break;\n            case \"parent\":\n                ctx = ctx.parent;\n                break;\n            default:\n                while(ctx.parent)ctx = ctx.parent;\n        }\n        let { type: type  } = this;\n        if (type == null) {\n            if (!(val instanceof $92184962f8f0d5e2$export$df5cb1f3d04f5a0f)) throw new Error(\"Must be a VoidPointer\");\n            ({ type: type  } = val);\n            val = val.value;\n        }\n        if (val && ctx) {\n            // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n            let size = type.size(val, parent);\n            ctx.pointerSize += size;\n        }\n        return this.offsetType.size();\n    }\n    encode(stream, val, ctx) {\n        let relative;\n        const parent = ctx;\n        if (val == null) {\n            this.offsetType.encode(stream, this.options.nullValue);\n            return;\n        }\n        switch(this.options.type){\n            case \"local\":\n                relative = ctx.startOffset;\n                break;\n            case \"immediate\":\n                relative = stream.pos + this.offsetType.size(val, parent);\n                break;\n            case \"parent\":\n                ctx = ctx.parent;\n                relative = ctx.startOffset;\n                break;\n            default:\n                relative = 0;\n                while(ctx.parent)ctx = ctx.parent;\n        }\n        if (this.options.relativeTo) relative += this.relativeToGetter(parent.val);\n        this.offsetType.encode(stream, ctx.pointerOffset - relative);\n        let { type: type  } = this;\n        if (type == null) {\n            if (!(val instanceof $92184962f8f0d5e2$export$df5cb1f3d04f5a0f)) throw new Error(\"Must be a VoidPointer\");\n            ({ type: type  } = val);\n            val = val.value;\n        }\n        ctx.pointers.push({\n            type: type,\n            val: val,\n            parent: parent\n        });\n        return ctx.pointerOffset += type.size(val, parent);\n    }\n}\nclass $92184962f8f0d5e2$export$df5cb1f3d04f5a0f {\n    constructor(type, value){\n        this.type = type;\n        this.value = value;\n    }\n}\n\n\n$parcel$exportWildcard(module.exports, $4559ecf940edc78d$exports);\n$parcel$exportWildcard(module.exports, $af65abf7bf65ac42$exports);\n$parcel$exportWildcard(module.exports, $92184962f8f0d5e2$exports);\n\n\n//# sourceMappingURL=main.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVzdHJ1Y3R1cmUvZGlzdC9tYWluLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLCtCQUErQixxREFBcUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFrQyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLElBQUk7QUFDekU7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhDQUE4QztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVuLXJlc3VtZS8uL25vZGVfbW9kdWxlcy9yZXN0cnVjdHVyZS9kaXN0L21haW4uY2pzPzYyZmIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gJHBhcmNlbCRleHBvcnQoZSwgbiwgdiwgcykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgbiwge2dldDogdiwgc2V0OiBzLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcbn1cbmZ1bmN0aW9uICRwYXJjZWwkZXhwb3J0V2lsZGNhcmQoZGVzdCwgc291cmNlKSB7XG4gIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoa2V5ID09PSAnZGVmYXVsdCcgfHwga2V5ID09PSAnX19lc01vZHVsZScgfHwgZGVzdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3QsIGtleSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBkZXN0O1xufVxuXG4kcGFyY2VsJGV4cG9ydChtb2R1bGUuZXhwb3J0cywgXCJFbmNvZGVTdHJlYW1cIiwgKCkgPT4gJDFlZDQ2MTgyYzE0MTBlMWQkZXhwb3J0JDliNGY2NjFkZWFhMzZjM2UpO1xuJHBhcmNlbCRleHBvcnQobW9kdWxlLmV4cG9ydHMsIFwiRGVjb2RlU3RyZWFtXCIsICgpID0+ICQ4YWUyMDU4M2I5M2U0OTMzJGV4cG9ydCRjMThiMzU0YmFjNzk0OGU5KTtcbiRwYXJjZWwkZXhwb3J0KG1vZHVsZS5leHBvcnRzLCBcIkFycmF5XCIsICgpID0+ICQ4ZWEyOGEwOGVhZTJhMTE2JGV4cG9ydCRjNGJlNjU3NmNhNmZlNGFhKTtcbiRwYXJjZWwkZXhwb3J0KG1vZHVsZS5leHBvcnRzLCBcIkxhenlBcnJheVwiLCAoKSA9PiAkNDQ0ZjExMmQzY2JjN2U5ZiRleHBvcnQkNTU3NmMwMjYwMjhkNDk4Myk7XG4kcGFyY2VsJGV4cG9ydChtb2R1bGUuZXhwb3J0cywgXCJCaXRmaWVsZFwiLCAoKSA9PiAkM2RlZjIzN2EzNGEyMjZiNSRleHBvcnQkOTZiNDNiOGE0OWY2ODhlYSk7XG4kcGFyY2VsJGV4cG9ydChtb2R1bGUuZXhwb3J0cywgXCJCb29sZWFuXCIsICgpID0+ICQ4NDE1ZTkxYmI4M2ZhZjc0JGV4cG9ydCRmZjg4N2NlZmVlNGQ2MWVjKTtcbiRwYXJjZWwkZXhwb3J0KG1vZHVsZS5leHBvcnRzLCBcIkJ1ZmZlclwiLCAoKSA9PiAkMDhkMjg2MDQxMTlhZjQ3ZSRleHBvcnQkN2QyMmEwZWVhNjY1NjQ3NCk7XG4kcGFyY2VsJGV4cG9ydChtb2R1bGUuZXhwb3J0cywgXCJFbnVtXCIsICgpID0+ICQwNzBjZTMxZWE5NDc0NjdmJGV4cG9ydCRkZWI4MjUwOGRkNjZkMjg4KTtcbiRwYXJjZWwkZXhwb3J0KG1vZHVsZS5leHBvcnRzLCBcIk9wdGlvbmFsXCIsICgpID0+ICQ4MDcwMzU0MmZjZmI2ZmYwJGV4cG9ydCQ3YWNiN2IyNGM0NzhmOWM2KTtcbiRwYXJjZWwkZXhwb3J0KG1vZHVsZS5leHBvcnRzLCBcIlJlc2VydmVkXCIsICgpID0+ICRmNGZkNDk4NzgyMzI1MDhhJGV4cG9ydCRkYTliNWZlMTg3YTlhYTEpO1xuJHBhcmNlbCRleHBvcnQobW9kdWxlLmV4cG9ydHMsIFwiU3RyaW5nXCIsICgpID0+ICRkODcwNWNkNDAyMmU3ZGNmJGV4cG9ydCQ4OWI4ZTBmYTY1ZjZhOTE0KTtcbiRwYXJjZWwkZXhwb3J0KG1vZHVsZS5leHBvcnRzLCBcIlN0cnVjdFwiLCAoKSA9PiAkYWE4YjY2YmFlNmFiZTY1OCRleHBvcnQkZWFiYzcxZjAxMWRmNjc1YSk7XG4kcGFyY2VsJGV4cG9ydChtb2R1bGUuZXhwb3J0cywgXCJWZXJzaW9uZWRTdHJ1Y3RcIiwgKCkgPT4gJGZjYjIwOGE5NWY2ZDA0OGIkZXhwb3J0JDk1YThiNjBmNGRhN2RlYzgpO1xuLy8gTm9kZSBiYWNrLWNvbXBhdC5cbmNvbnN0ICQ4YWUyMDU4M2I5M2U0OTMzJHZhciRFTkNPRElOR19NQVBQSU5HID0ge1xuICAgIHV0ZjE2bGU6IFwidXRmLTE2bGVcIixcbiAgICB1Y3MyOiBcInV0Zi0xNmxlXCIsXG4gICAgdXRmMTZiZTogXCJ1dGYtMTZiZVwiXG59O1xuY2xhc3MgJDhhZTIwNTgzYjkzZTQ5MzMkZXhwb3J0JGMxOGIzNTRiYWM3OTQ4ZTkge1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlcil7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLmJ1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgcmVhZFN0cmluZyhsZW5ndGgsIGVuY29kaW5nID0gXCJhc2NpaVwiKSB7XG4gICAgICAgIGVuY29kaW5nID0gJDhhZTIwNTgzYjkzZTQ5MzMkdmFyJEVOQ09ESU5HX01BUFBJTkdbZW5jb2RpbmddIHx8IGVuY29kaW5nO1xuICAgICAgICBsZXQgYnVmID0gdGhpcy5yZWFkQnVmZmVyKGxlbmd0aCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZyk7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnVmKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWRCdWZmZXIobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgKz0gbGVuZ3RoKTtcbiAgICB9XG4gICAgcmVhZFVJbnQyNEJFKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucmVhZFVJbnQxNkJFKCkgPDwgOCkgKyB0aGlzLnJlYWRVSW50OCgpO1xuICAgIH1cbiAgICByZWFkVUludDI0TEUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRVSW50MTZMRSgpICsgKHRoaXMucmVhZFVJbnQ4KCkgPDwgMTYpO1xuICAgIH1cbiAgICByZWFkSW50MjRCRSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnJlYWRJbnQxNkJFKCkgPDwgOCkgKyB0aGlzLnJlYWRVSW50OCgpO1xuICAgIH1cbiAgICByZWFkSW50MjRMRSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVJbnQxNkxFKCkgKyAodGhpcy5yZWFkSW50OCgpIDw8IDE2KTtcbiAgICB9XG59XG4kOGFlMjA1ODNiOTNlNDkzMyRleHBvcnQkYzE4YjM1NGJhYzc5NDhlOS5UWVBFUyA9IHtcbiAgICBVSW50ODogMSxcbiAgICBVSW50MTY6IDIsXG4gICAgVUludDI0OiAzLFxuICAgIFVJbnQzMjogNCxcbiAgICBJbnQ4OiAxLFxuICAgIEludDE2OiAyLFxuICAgIEludDI0OiAzLFxuICAgIEludDMyOiA0LFxuICAgIEZsb2F0OiA0LFxuICAgIERvdWJsZTogOFxufTtcbmZvciAobGV0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhEYXRhVmlldy5wcm90b3R5cGUpKWlmIChrZXkuc2xpY2UoMCwgMykgPT09IFwiZ2V0XCIpIHtcbiAgICBsZXQgdHlwZSA9IGtleS5zbGljZSgzKS5yZXBsYWNlKFwiVWlcIiwgXCJVSVwiKTtcbiAgICBpZiAodHlwZSA9PT0gXCJGbG9hdDMyXCIpIHR5cGUgPSBcIkZsb2F0XCI7XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJGbG9hdDY0XCIpIHR5cGUgPSBcIkRvdWJsZVwiO1xuICAgIGxldCBieXRlcyA9ICQ4YWUyMDU4M2I5M2U0OTMzJGV4cG9ydCRjMThiMzU0YmFjNzk0OGU5LlRZUEVTW3R5cGVdO1xuICAgICQ4YWUyMDU4M2I5M2U0OTMzJGV4cG9ydCRjMThiMzU0YmFjNzk0OGU5LnByb3RvdHlwZVtcInJlYWRcIiArIHR5cGUgKyAoYnl0ZXMgPT09IDEgPyBcIlwiIDogXCJCRVwiKV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy52aWV3W2tleV0odGhpcy5wb3MsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gYnl0ZXM7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpZiAoYnl0ZXMgIT09IDEpICQ4YWUyMDU4M2I5M2U0OTMzJGV4cG9ydCRjMThiMzU0YmFjNzk0OGU5LnByb3RvdHlwZVtcInJlYWRcIiArIHR5cGUgKyBcIkxFXCJdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMudmlld1trZXldKHRoaXMucG9zLCB0cnVlKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gYnl0ZXM7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn1cblxuXG5jb25zdCAkMWVkNDYxODJjMTQxMGUxZCR2YXIkdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmNvbnN0ICQxZWQ0NjE4MmMxNDEwZTFkJHZhciRpc0JpZ0VuZGlhbiA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MTZBcnJheShbXG4gICAgMHgxMjM0XG5dKS5idWZmZXIpWzBdID09IDB4MTI7XG5jbGFzcyAkMWVkNDYxODJjMTQxMGUxZCRleHBvcnQkOWI0ZjY2MWRlYWEzNmMzZSB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyKXtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLmJ1ZmZlci5idWZmZXIsIHRoaXMuYnVmZmVyLmJ5dGVPZmZzZXQsIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIHdyaXRlQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLmJ1ZmZlci5zZXQoYnVmZmVyLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIHdyaXRlU3RyaW5nKHN0cmluZywgZW5jb2RpbmcgPSBcImFzY2lpXCIpIHtcbiAgICAgICAgbGV0IGJ1ZjtcbiAgICAgICAgc3dpdGNoKGVuY29kaW5nKXtcbiAgICAgICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwidXRmMTYtbGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1Y3MyXCI6XG4gICAgICAgICAgICAgICAgYnVmID0gJDFlZDQ2MTgyYzE0MTBlMWQkdmFyJHN0cmluZ1RvVXRmMTYoc3RyaW5nLCAkMWVkNDYxODJjMTQxMGUxZCR2YXIkaXNCaWdFbmRpYW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInV0ZjE2YmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1dGYxNi1iZVwiOlxuICAgICAgICAgICAgICAgIGJ1ZiA9ICQxZWQ0NjE4MmMxNDEwZTFkJHZhciRzdHJpbmdUb1V0ZjE2KHN0cmluZywgISQxZWQ0NjE4MmMxNDEwZTFkJHZhciRpc0JpZ0VuZGlhbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgICAgICAgICAgIGJ1ZiA9ICQxZWQ0NjE4MmMxNDEwZTFkJHZhciR0ZXh0RW5jb2Rlci5lbmNvZGUoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgICAgICAgICAgIGJ1ZiA9ICQxZWQ0NjE4MmMxNDEwZTFkJHZhciRzdHJpbmdUb0FzY2lpKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZW5jb2Rpbmc6ICR7ZW5jb2Rpbmd9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihidWYpO1xuICAgIH1cbiAgICB3cml0ZVVJbnQyNEJFKHZhbCkge1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvcysrXSA9IHZhbCA+Pj4gMTYgJiAweGZmO1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvcysrXSA9IHZhbCA+Pj4gOCAmIDB4ZmY7XG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zKytdID0gdmFsICYgMHhmZjtcbiAgICB9XG4gICAgd3JpdGVVSW50MjRMRSh2YWwpIHtcbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3MrK10gPSB2YWwgJiAweGZmO1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvcysrXSA9IHZhbCA+Pj4gOCAmIDB4ZmY7XG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zKytdID0gdmFsID4+PiAxNiAmIDB4ZmY7XG4gICAgfVxuICAgIHdyaXRlSW50MjRCRSh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA+PSAwKSB0aGlzLndyaXRlVUludDI0QkUodmFsKTtcbiAgICAgICAgZWxzZSB0aGlzLndyaXRlVUludDI0QkUodmFsICsgMHhmZmZmZmYgKyAxKTtcbiAgICB9XG4gICAgd3JpdGVJbnQyNExFKHZhbCkge1xuICAgICAgICBpZiAodmFsID49IDApIHRoaXMud3JpdGVVSW50MjRMRSh2YWwpO1xuICAgICAgICBlbHNlIHRoaXMud3JpdGVVSW50MjRMRSh2YWwgKyAweGZmZmZmZiArIDEpO1xuICAgIH1cbiAgICBmaWxsKHZhbCwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChsZW5ndGggPCB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLmZpbGwodmFsLCB0aGlzLnBvcywgdGhpcy5wb3MgKyBsZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIGJ1Zi5maWxsKHZhbCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyKGJ1Zik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiAkMWVkNDYxODJjMTQxMGUxZCR2YXIkc3RyaW5nVG9VdGYxNihzdHJpbmcsIHN3YXApIHtcbiAgICBsZXQgYnVmID0gbmV3IFVpbnQxNkFycmF5KHN0cmluZy5sZW5ndGgpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspe1xuICAgICAgICBsZXQgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoc3dhcCkgY29kZSA9IGNvZGUgPj4gOCB8IChjb2RlICYgMHhmZikgPDwgODtcbiAgICAgICAgYnVmW2ldID0gY29kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIpO1xufVxuZnVuY3Rpb24gJDFlZDQ2MTgyYzE0MTBlMWQkdmFyJHN0cmluZ1RvQXNjaWkoc3RyaW5nKSB7XG4gICAgbGV0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KHN0cmluZy5sZW5ndGgpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspLy8gTWF0Y2ggbm9kZS5qcyBiZWhhdmlvciAtIGVuY29kaW5nIGFsbG93cyA4LWJpdCByYXRoZXIgdGhhbiA3LWJpdC5cbiAgICBidWZbaV0gPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYnVmO1xufVxuZm9yIChsZXQga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKERhdGFWaWV3LnByb3RvdHlwZSkpaWYgKGtleS5zbGljZSgwLCAzKSA9PT0gXCJzZXRcIikge1xuICAgIGxldCB0eXBlID0ga2V5LnNsaWNlKDMpLnJlcGxhY2UoXCJVaVwiLCBcIlVJXCIpO1xuICAgIGlmICh0eXBlID09PSBcIkZsb2F0MzJcIikgdHlwZSA9IFwiRmxvYXRcIjtcbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkZsb2F0NjRcIikgdHlwZSA9IFwiRG91YmxlXCI7XG4gICAgbGV0IGJ5dGVzID0gKDAsICQ4YWUyMDU4M2I5M2U0OTMzJGV4cG9ydCRjMThiMzU0YmFjNzk0OGU5KS5UWVBFU1t0eXBlXTtcbiAgICAkMWVkNDYxODJjMTQxMGUxZCRleHBvcnQkOWI0ZjY2MWRlYWEzNmMzZS5wcm90b3R5cGVbXCJ3cml0ZVwiICsgdHlwZSArIChieXRlcyA9PT0gMSA/IFwiXCIgOiBcIkJFXCIpXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmlld1trZXldKHRoaXMucG9zLCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLnBvcyArPSBieXRlcztcbiAgICB9O1xuICAgIGlmIChieXRlcyAhPT0gMSkgJDFlZDQ2MTgyYzE0MTBlMWQkZXhwb3J0JDliNGY2NjFkZWFhMzZjM2UucHJvdG90eXBlW1wid3JpdGVcIiArIHR5cGUgKyBcIkxFXCJdID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy52aWV3W2tleV0odGhpcy5wb3MsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gYnl0ZXM7XG4gICAgfTtcbn1cblxuXG5cblxuXG5jbGFzcyAkOGQyMWY3ZmE1ODgwMjkwMSRleHBvcnQkZWY4OGFhMGQzNGMzNDUyMCB7XG4gICAgZnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyAoMCwgJDhhZTIwNTgzYjkzZTQ5MzMkZXhwb3J0JGMxOGIzNTRiYWM3OTQ4ZTkpKGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZShzdHJlYW0pO1xuICAgIH1cbiAgICB0b0J1ZmZlcih2YWx1ZSkge1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuc2l6ZSh2YWx1ZSk7XG4gICAgICAgIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyAoMCwgJDFlZDQ2MTgyYzE0MTBlMWQkZXhwb3J0JDliNGY2NjFkZWFhMzZjM2UpKGJ1ZmZlcik7XG4gICAgICAgIHRoaXMuZW5jb2RlKHN0cmVhbSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbn1cblxuXG52YXIgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cyA9IHt9O1xuXG4kcGFyY2VsJGV4cG9ydCgkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnRzLCBcIk51bWJlclwiLCAoKSA9PiAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZmZmYTY3ZTUxNWQwNDAyMik7XG4kcGFyY2VsJGV4cG9ydCgkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnRzLCBcInVpbnQ4XCIsICgpID0+ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQ1MmUxMDNjNjNjNGU2OGNmKTtcbiRwYXJjZWwkZXhwb3J0KCRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydHMsIFwidWludDE2YmVcIiwgKCkgPT4gJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDYwZGZlNDNjODI5N2E4ZjgpO1xuJHBhcmNlbCRleHBvcnQoJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cywgXCJ1aW50MTZcIiwgKCkgPT4gJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDU2YmQyNGI1YTNlZTg0NTYpO1xuJHBhcmNlbCRleHBvcnQoJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cywgXCJ1aW50MTZsZVwiLCAoKSA9PiAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkYjkyZDc2ZjBjYTZkMTc4OSk7XG4kcGFyY2VsJGV4cG9ydCgkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnRzLCBcInVpbnQyNGJlXCIsICgpID0+ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQyNTVmNDUxNzFmOTZiNTBjKTtcbiRwYXJjZWwkZXhwb3J0KCRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydHMsIFwidWludDI0XCIsICgpID0+ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQxOTI1Mjk4ZmJkNzE5YjIxKTtcbiRwYXJjZWwkZXhwb3J0KCRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydHMsIFwidWludDI0bGVcIiwgKCkgPT4gJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDc1OGUxZGFmYzhkYzcyNzEpO1xuJHBhcmNlbCRleHBvcnQoJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cywgXCJ1aW50MzJiZVwiLCAoKSA9PiAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkNzRjMTZkYmE2Yzg4NTUzMik7XG4kcGFyY2VsJGV4cG9ydCgkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnRzLCBcInVpbnQzMlwiLCAoKSA9PiAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZGU5ZmZiOTQxOGRkN2QwZCk7XG4kcGFyY2VsJGV4cG9ydCgkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnRzLCBcInVpbnQzMmxlXCIsICgpID0+ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQ1Zjc0NGJiMzBhNTM0YmM5KTtcbiRwYXJjZWwkZXhwb3J0KCRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydHMsIFwiaW50OFwiLCAoKSA9PiAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkNTk4NGYyNWVhYjA5OTYxZik7XG4kcGFyY2VsJGV4cG9ydCgkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnRzLCBcImludDE2YmVcIiwgKCkgPT4gJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDE5OGFlN2QxMGQyNmE5MDApO1xuJHBhcmNlbCRleHBvcnQoJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cywgXCJpbnQxNlwiLCAoKSA9PiAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkYzM1YzE1YzdjYWVmZjJiNik7XG4kcGFyY2VsJGV4cG9ydCgkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnRzLCBcImludDE2bGVcIiwgKCkgPT4gJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDM5OWNjNGI3MTY5ZTVhZWQpO1xuJHBhcmNlbCRleHBvcnQoJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cywgXCJpbnQyNGJlXCIsICgpID0+ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQzNjc2ZDFmNzFlY2EyZWMwKTtcbiRwYXJjZWwkZXhwb3J0KCRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydHMsIFwiaW50MjRcIiwgKCkgPT4gJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDczZjY5NWQ2ODFhYzYxZjkpO1xuJHBhcmNlbCRleHBvcnQoJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cywgXCJpbnQyNGxlXCIsICgpID0+ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQ2NzFmODY3MmRiZDQwYTQpO1xuJHBhcmNlbCRleHBvcnQoJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cywgXCJpbnQzMmJlXCIsICgpID0+ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQ3OGEyYWMzZDA5ZGQ0MmQ1KTtcbiRwYXJjZWwkZXhwb3J0KCRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydHMsIFwiaW50MzJcIiwgKCkgPT4gJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDFkOTU4MzUzODNiYjA1YSk7XG4kcGFyY2VsJGV4cG9ydCgkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnRzLCBcImludDMybGVcIiwgKCkgPT4gJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDVlYzFmMTQ2ZTc1OTMyOWEpO1xuJHBhcmNlbCRleHBvcnQoJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cywgXCJmbG9hdGJlXCIsICgpID0+ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQ5MmI1YzE0YzZhYmI1Yzk3KTtcbiRwYXJjZWwkZXhwb3J0KCRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydHMsIFwiZmxvYXRcIiwgKCkgPT4gJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDZiNWNkMzk4M2UzZWU1YWIpO1xuJHBhcmNlbCRleHBvcnQoJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cywgXCJmbG9hdGxlXCIsICgpID0+ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQ2ZDIwNTkyYmM0Y2IxOWQ5KTtcbiRwYXJjZWwkZXhwb3J0KCRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydHMsIFwiZG91YmxlYmVcIiwgKCkgPT4gJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGU1MGI5ZTk3ZTRkNDM2MzEpO1xuJHBhcmNlbCRleHBvcnQoJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cywgXCJkb3VibGVcIiwgKCkgPT4gJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDdiM2NiZGE2N2JlODhmNWYpO1xuJHBhcmNlbCRleHBvcnQoJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cywgXCJkb3VibGVsZVwiLCAoKSA9PiAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkNmY1MzMxNWFhNTEyYjc1MSk7XG4kcGFyY2VsJGV4cG9ydCgkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnRzLCBcIkZpeGVkXCIsICgpID0+ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQxMzQ3NWJiZDJhMzdhOWI0KTtcbiRwYXJjZWwkZXhwb3J0KCRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydHMsIFwiZml4ZWQxNmJlXCIsICgpID0+ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRmODdiNDQxZTZiZDkwMjc4KTtcbiRwYXJjZWwkZXhwb3J0KCRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydHMsIFwiZml4ZWQxNlwiLCAoKSA9PiAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkYTNhYmFkYTc1ZWY1NTkyMSk7XG4kcGFyY2VsJGV4cG9ydCgkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnRzLCBcImZpeGVkMTZsZVwiLCAoKSA9PiAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkMzc1MmEyODg2ODM3ZGMyMik7XG4kcGFyY2VsJGV4cG9ydCgkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnRzLCBcImZpeGVkMzJiZVwiLCAoKSA9PiAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZGQ3MWQ4ZDliYzc5MjYzMik7XG4kcGFyY2VsJGV4cG9ydCgkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnRzLCBcImZpeGVkMzJcIiwgKCkgPT4gJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGU5MTMyNjVkNDg0NzFmMmQpO1xuJHBhcmNlbCRleHBvcnQoJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cywgXCJmaXhlZDMybGVcIiwgKCkgPT4gJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDdmYzQ3ZGI2YTVmYzgyMjMpO1xuXG5cbmNsYXNzICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRmZmZhNjdlNTE1ZDA0MDIyIGV4dGVuZHMgKDAsICQ4ZDIxZjdmYTU4ODAyOTAxJGV4cG9ydCRlZjg4YWEwZDM0YzM0NTIwKSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgZW5kaWFuID0gXCJCRVwiKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5lbmRpYW4gPSBlbmRpYW47XG4gICAgICAgIHRoaXMuZm4gPSB0aGlzLnR5cGU7XG4gICAgICAgIGlmICh0aGlzLnR5cGVbdGhpcy50eXBlLmxlbmd0aCAtIDFdICE9PSBcIjhcIikgdGhpcy5mbiArPSB0aGlzLmVuZGlhbjtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuICgwLCAkOGFlMjA1ODNiOTNlNDkzMyRleHBvcnQkYzE4YjM1NGJhYzc5NDhlOSkuVFlQRVNbdGhpcy50eXBlXTtcbiAgICB9XG4gICAgZGVjb2RlKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW2ByZWFkJHt0aGlzLmZufWBdKCk7XG4gICAgfVxuICAgIGVuY29kZShzdHJlYW0sIHZhbCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW2B3cml0ZSR7dGhpcy5mbn1gXSh2YWwpO1xuICAgIH1cbn1cbmNvbnN0ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQ1MmUxMDNjNjNjNGU2OGNmID0gbmV3ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRmZmZhNjdlNTE1ZDA0MDIyKFwiVUludDhcIik7XG5jb25zdCAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkNjBkZmU0M2M4Mjk3YThmOCA9IG5ldyAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZmZmYTY3ZTUxNWQwNDAyMihcIlVJbnQxNlwiLCBcIkJFXCIpO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDU2YmQyNGI1YTNlZTg0NTYgPSAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkNjBkZmU0M2M4Mjk3YThmODtcbmNvbnN0ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRiOTJkNzZmMGNhNmQxNzg5ID0gbmV3ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRmZmZhNjdlNTE1ZDA0MDIyKFwiVUludDE2XCIsIFwiTEVcIik7XG5jb25zdCAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkMjU1ZjQ1MTcxZjk2YjUwYyA9IG5ldyAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZmZmYTY3ZTUxNWQwNDAyMihcIlVJbnQyNFwiLCBcIkJFXCIpO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDE5MjUyOThmYmQ3MTliMjEgPSAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkMjU1ZjQ1MTcxZjk2YjUwYztcbmNvbnN0ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQ3NThlMWRhZmM4ZGM3MjcxID0gbmV3ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRmZmZhNjdlNTE1ZDA0MDIyKFwiVUludDI0XCIsIFwiTEVcIik7XG5jb25zdCAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkNzRjMTZkYmE2Yzg4NTUzMiA9IG5ldyAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZmZmYTY3ZTUxNWQwNDAyMihcIlVJbnQzMlwiLCBcIkJFXCIpO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGRlOWZmYjk0MThkZDdkMGQgPSAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkNzRjMTZkYmE2Yzg4NTUzMjtcbmNvbnN0ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQ1Zjc0NGJiMzBhNTM0YmM5ID0gbmV3ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRmZmZhNjdlNTE1ZDA0MDIyKFwiVUludDMyXCIsIFwiTEVcIik7XG5jb25zdCAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkNTk4NGYyNWVhYjA5OTYxZiA9IG5ldyAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZmZmYTY3ZTUxNWQwNDAyMihcIkludDhcIik7XG5jb25zdCAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkMTk4YWU3ZDEwZDI2YTkwMCA9IG5ldyAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZmZmYTY3ZTUxNWQwNDAyMihcIkludDE2XCIsIFwiQkVcIik7XG5jb25zdCAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkYzM1YzE1YzdjYWVmZjJiNiA9ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQxOThhZTdkMTBkMjZhOTAwO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDM5OWNjNGI3MTY5ZTVhZWQgPSBuZXcgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGZmZmE2N2U1MTVkMDQwMjIoXCJJbnQxNlwiLCBcIkxFXCIpO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDM2NzZkMWY3MWVjYTJlYzAgPSBuZXcgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGZmZmE2N2U1MTVkMDQwMjIoXCJJbnQyNFwiLCBcIkJFXCIpO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDczZjY5NWQ2ODFhYzYxZjkgPSAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkMzY3NmQxZjcxZWNhMmVjMDtcbmNvbnN0ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQ2NzFmODY3MmRiZDQwYTQgPSBuZXcgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGZmZmE2N2U1MTVkMDQwMjIoXCJJbnQyNFwiLCBcIkxFXCIpO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDc4YTJhYzNkMDlkZDQyZDUgPSBuZXcgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGZmZmE2N2U1MTVkMDQwMjIoXCJJbnQzMlwiLCBcIkJFXCIpO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDFkOTU4MzUzODNiYjA1YSA9ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQ3OGEyYWMzZDA5ZGQ0MmQ1O1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDVlYzFmMTQ2ZTc1OTMyOWEgPSBuZXcgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGZmZmE2N2U1MTVkMDQwMjIoXCJJbnQzMlwiLCBcIkxFXCIpO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDkyYjVjMTRjNmFiYjVjOTcgPSBuZXcgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGZmZmE2N2U1MTVkMDQwMjIoXCJGbG9hdFwiLCBcIkJFXCIpO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDZiNWNkMzk4M2UzZWU1YWIgPSAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkOTJiNWMxNGM2YWJiNWM5NztcbmNvbnN0ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQ2ZDIwNTkyYmM0Y2IxOWQ5ID0gbmV3ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRmZmZhNjdlNTE1ZDA0MDIyKFwiRmxvYXRcIiwgXCJMRVwiKTtcbmNvbnN0ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRlNTBiOWU5N2U0ZDQzNjMxID0gbmV3ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRmZmZhNjdlNTE1ZDA0MDIyKFwiRG91YmxlXCIsIFwiQkVcIik7XG5jb25zdCAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkN2IzY2JkYTY3YmU4OGY1ZiA9ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRlNTBiOWU5N2U0ZDQzNjMxO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDZmNTMzMTVhYTUxMmI3NTEgPSBuZXcgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGZmZmE2N2U1MTVkMDQwMjIoXCJEb3VibGVcIiwgXCJMRVwiKTtcbmNsYXNzICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQxMzQ3NWJiZDJhMzdhOWI0IGV4dGVuZHMgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGZmZmE2N2U1MTVkMDQwMjIge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIGVuZGlhbiwgZnJhY0JpdHMgPSBzaXplID4+IDEpe1xuICAgICAgICBzdXBlcihgSW50JHtzaXplfWAsIGVuZGlhbik7XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMSA8PCBmcmFjQml0cztcbiAgICB9XG4gICAgZGVjb2RlKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZGVjb2RlKHN0cmVhbSkgLyB0aGlzLl9wb2ludDtcbiAgICB9XG4gICAgZW5jb2RlKHN0cmVhbSwgdmFsKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbmNvZGUoc3RyZWFtLCB2YWwgKiB0aGlzLl9wb2ludCB8IDApO1xuICAgIH1cbn1cbmNvbnN0ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRmODdiNDQxZTZiZDkwMjc4ID0gbmV3ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQxMzQ3NWJiZDJhMzdhOWI0KDE2LCBcIkJFXCIpO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGEzYWJhZGE3NWVmNTU5MjEgPSAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZjg3YjQ0MWU2YmQ5MDI3ODtcbmNvbnN0ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQzNzUyYTI4ODY4MzdkYzIyID0gbmV3ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCQxMzQ3NWJiZDJhMzdhOWI0KDE2LCBcIkxFXCIpO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGRkNzFkOGQ5YmM3OTI2MzIgPSBuZXcgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDEzNDc1YmJkMmEzN2E5YjQoMzIsIFwiQkVcIik7XG5jb25zdCAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZTkxMzI2NWQ0ODQ3MWYyZCA9ICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRkZDcxZDhkOWJjNzkyNjMyO1xuY29uc3QgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDdmYzQ3ZGI2YTVmYzgyMjMgPSBuZXcgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JDEzNDc1YmJkMmEzN2E5YjQoMzIsIFwiTEVcIik7XG5cblxudmFyICQ0NTU5ZWNmOTQwZWRjNzhkJGV4cG9ydHMgPSB7fTtcblxuJHBhcmNlbCRleHBvcnQoJDQ1NTllY2Y5NDBlZGM3OGQkZXhwb3J0cywgXCJyZXNvbHZlTGVuZ3RoXCIsICgpID0+ICQ0NTU5ZWNmOTQwZWRjNzhkJGV4cG9ydCQ4M2I2ZGMzNTAzYzFmZGE2KTtcbiRwYXJjZWwkZXhwb3J0KCQ0NTU5ZWNmOTQwZWRjNzhkJGV4cG9ydHMsIFwiUHJvcGVydHlEZXNjcmlwdG9yXCIsICgpID0+ICQ0NTU5ZWNmOTQwZWRjNzhkJGV4cG9ydCQ0MTcwNWIxZDY0NGUwZjE0KTtcblxuZnVuY3Rpb24gJDQ1NTllY2Y5NDBlZGM3OGQkZXhwb3J0JDgzYjZkYzM1MDNjMWZkYTYobGVuZ3RoLCBzdHJlYW0sIHBhcmVudCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpIHJlcyA9IGxlbmd0aDtcbiAgICBlbHNlIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcImZ1bmN0aW9uXCIpIHJlcyA9IGxlbmd0aC5jYWxsKHBhcmVudCwgcGFyZW50KTtcbiAgICBlbHNlIGlmIChwYXJlbnQgJiYgdHlwZW9mIGxlbmd0aCA9PT0gXCJzdHJpbmdcIikgcmVzID0gcGFyZW50W2xlbmd0aF07XG4gICAgZWxzZSBpZiAoc3RyZWFtICYmIGxlbmd0aCBpbnN0YW5jZW9mICgwLCAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZmZmYTY3ZTUxNWQwNDAyMikpIHJlcyA9IGxlbmd0aC5kZWNvZGUoc3RyZWFtKTtcbiAgICBpZiAoaXNOYU4ocmVzKSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgZml4ZWQgc2l6ZVwiKTtcbiAgICByZXR1cm4gcmVzO1xufVxuY2xhc3MgJDQ1NTllY2Y5NDBlZGM3OGQkZXhwb3J0JDQxNzA1YjFkNjQ0ZTBmMTQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSl7XG4gICAgICAgIHRoaXMuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gb3B0cyl7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBvcHRzW2tleV07XG4gICAgICAgICAgICB0aGlzW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuY2xhc3MgJDhlYTI4YTA4ZWFlMmExMTYkZXhwb3J0JGM0YmU2NTc2Y2E2ZmU0YWEgZXh0ZW5kcyAoMCwgJDhkMjFmN2ZhNTg4MDI5MDEkZXhwb3J0JGVmODhhYTBkMzRjMzQ1MjApIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBsZW5ndGgsIGxlbmd0aFR5cGUgPSBcImNvdW50XCIpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5sZW5ndGhUeXBlID0gbGVuZ3RoVHlwZTtcbiAgICB9XG4gICAgZGVjb2RlKHN0cmVhbSwgcGFyZW50KSB7XG4gICAgICAgIGxldCBsZW5ndGg7XG4gICAgICAgIGNvbnN0IHsgcG9zOiBwb3MgIH0gPSBzdHJlYW07XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBsZXQgY3R4ID0gcGFyZW50O1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT0gbnVsbCkgbGVuZ3RoID0gJDQ1NTllY2Y5NDBlZGM3OGQkZXhwb3J0JDgzYjZkYzM1MDNjMWZkYTYodGhpcy5sZW5ndGgsIHN0cmVhbSwgcGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIGluc3RhbmNlb2YgKDAsICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRmZmZhNjdlNTE1ZDA0MDIyKSkge1xuICAgICAgICAgICAgLy8gZGVmaW5lIGhpZGRlbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhyZXMsIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcmVudFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX3N0YXJ0T2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwb3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9jdXJyZW50T2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2xlbmd0aDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbGVuZ3RoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdHggPSByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PSBudWxsIHx8IHRoaXMubGVuZ3RoVHlwZSA9PT0gXCJieXRlc1wiKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBsZW5ndGggIT0gbnVsbCA/IHN0cmVhbS5wb3MgKyBsZW5ndGggOiAocGFyZW50ICE9IG51bGwgPyBwYXJlbnQuX2xlbmd0aCA6IHVuZGVmaW5lZCkgPyBwYXJlbnQuX3N0YXJ0T2Zmc2V0ICsgcGFyZW50Ll9sZW5ndGggOiBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUoc3RyZWFtLnBvcyA8IHRhcmdldClyZXMucHVzaCh0aGlzLnR5cGUuZGVjb2RlKHN0cmVhbSwgY3R4KSk7XG4gICAgICAgIH0gZWxzZSBmb3IobGV0IGkgPSAwLCBlbmQgPSBsZW5ndGg7IGkgPCBlbmQ7IGkrKylyZXMucHVzaCh0aGlzLnR5cGUuZGVjb2RlKHN0cmVhbSwgY3R4KSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHNpemUoYXJyYXksIGN0eCwgaW5jbHVkZVBvaW50ZXJzID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIWFycmF5KSByZXR1cm4gdGhpcy50eXBlLnNpemUobnVsbCwgY3R4KSAqICQ0NTU5ZWNmOTQwZWRjNzhkJGV4cG9ydCQ4M2I2ZGMzNTAzYzFmZGE2KHRoaXMubGVuZ3RoLCBudWxsLCBjdHgpO1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCBpbnN0YW5jZW9mICgwLCAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZmZmYTY3ZTUxNWQwNDAyMikpIHtcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5sZW5ndGguc2l6ZSgpO1xuICAgICAgICAgICAgY3R4ID0ge1xuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIHBvaW50ZXJTaXplOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgYXJyYXkpc2l6ZSArPSB0aGlzLnR5cGUuc2l6ZShpdGVtLCBjdHgpO1xuICAgICAgICBpZiAoY3R4ICYmIGluY2x1ZGVQb2ludGVycyAmJiB0aGlzLmxlbmd0aCBpbnN0YW5jZW9mICgwLCAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZmZmYTY3ZTUxNWQwNDAyMikpIHNpemUgKz0gY3R4LnBvaW50ZXJTaXplO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgZW5jb2RlKHN0cmVhbSwgYXJyYXksIHBhcmVudCkge1xuICAgICAgICBsZXQgY3R4ID0gcGFyZW50O1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggaW5zdGFuY2VvZiAoMCwgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGZmZmE2N2U1MTVkMDQwMjIpKSB7XG4gICAgICAgICAgICBjdHggPSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlcnM6IFtdLFxuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdHJlYW0ucG9zLFxuICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3R4LnBvaW50ZXJPZmZzZXQgPSBzdHJlYW0ucG9zICsgdGhpcy5zaXplKGFycmF5LCBjdHgsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoLmVuY29kZShzdHJlYW0sIGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBhcnJheSl0aGlzLnR5cGUuZW5jb2RlKHN0cmVhbSwgaXRlbSwgY3R4KTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIGluc3RhbmNlb2YgKDAsICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRmZmZhNjdlNTE1ZDA0MDIyKSkge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUoaSA8IGN0eC5wb2ludGVycy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIGNvbnN0IHB0ciA9IGN0eC5wb2ludGVyc1tpKytdO1xuICAgICAgICAgICAgICAgIHB0ci50eXBlLmVuY29kZShzdHJlYW0sIHB0ci52YWwsIHB0ci5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuXG5cbmNsYXNzICQ0NDRmMTEyZDNjYmM3ZTlmJGV4cG9ydCQ1NTc2YzAyNjAyOGQ0OTgzIGV4dGVuZHMgKDAsICQ4ZWEyOGEwOGVhZTJhMTE2JGV4cG9ydCRjNGJlNjU3NmNhNmZlNGFhKSB7XG4gICAgZGVjb2RlKHN0cmVhbSwgcGFyZW50KSB7XG4gICAgICAgIGNvbnN0IHsgcG9zOiBwb3MgIH0gPSBzdHJlYW07XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICQ0NTU5ZWNmOTQwZWRjNzhkJGV4cG9ydCQ4M2I2ZGMzNTAzYzFmZGE2KHRoaXMubGVuZ3RoLCBzdHJlYW0sIHBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCBpbnN0YW5jZW9mICgwLCAkYWY2NWFiZjdiZjY1YWM0MiRleHBvcnQkZmZmYTY3ZTUxNWQwNDAyMikpIHBhcmVudCA9IHtcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgX3N0YXJ0T2Zmc2V0OiBwb3MsXG4gICAgICAgICAgICBfY3VycmVudE9mZnNldDogMCxcbiAgICAgICAgICAgIF9sZW5ndGg6IGxlbmd0aFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgJDQ0NGYxMTJkM2NiYzdlOWYkdmFyJExhenlBcnJheVZhbHVlKHRoaXMudHlwZSwgbGVuZ3RoLCBzdHJlYW0sIHBhcmVudCk7XG4gICAgICAgIHN0cmVhbS5wb3MgKz0gbGVuZ3RoICogdGhpcy50eXBlLnNpemUobnVsbCwgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc2l6ZSh2YWwsIGN0eCkge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgJDQ0NGYxMTJkM2NiYzdlOWYkdmFyJExhenlBcnJheVZhbHVlKSB2YWwgPSB2YWwudG9BcnJheSgpO1xuICAgICAgICByZXR1cm4gc3VwZXIuc2l6ZSh2YWwsIGN0eCk7XG4gICAgfVxuICAgIGVuY29kZShzdHJlYW0sIHZhbCwgY3R4KSB7XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiAkNDQ0ZjExMmQzY2JjN2U5ZiR2YXIkTGF6eUFycmF5VmFsdWUpIHZhbCA9IHZhbC50b0FycmF5KCk7XG4gICAgICAgIHJldHVybiBzdXBlci5lbmNvZGUoc3RyZWFtLCB2YWwsIGN0eCk7XG4gICAgfVxufVxuY2xhc3MgJDQ0NGYxMTJkM2NiYzdlOWYkdmFyJExhenlBcnJheVZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBsZW5ndGgsIHN0cmVhbSwgY3R4KXtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgICAgdGhpcy5iYXNlID0gdGhpcy5zdHJlYW0ucG9zO1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgfVxuICAgIGdldChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5pdGVtc1tpbmRleF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyBwb3M6IHBvcyAgfSA9IHRoaXMuc3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ucG9zID0gdGhpcy5iYXNlICsgdGhpcy50eXBlLnNpemUobnVsbCwgdGhpcy5jdHgpICogaW5kZXg7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2luZGV4XSA9IHRoaXMudHlwZS5kZWNvZGUodGhpcy5zdHJlYW0sIHRoaXMuY3R4KTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBvcyA9IHBvcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1tpbmRleF07XG4gICAgfVxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IobGV0IGkgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aDsgaSA8IGVuZDsgaSsrKXJlc3VsdC5wdXNoKHRoaXMuZ2V0KGkpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cblxuXG5jbGFzcyAkM2RlZjIzN2EzNGEyMjZiNSRleHBvcnQkOTZiNDNiOGE0OWY2ODhlYSBleHRlbmRzICgwLCAkOGQyMWY3ZmE1ODgwMjkwMSRleHBvcnQkZWY4OGFhMGQzNGMzNDUyMCkge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGZsYWdzID0gW10pe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIGRlY29kZShzdHJlYW0pIHtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy50eXBlLmRlY29kZShzdHJlYW0pO1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZmxhZ3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgZmxhZyA9IHRoaXMuZmxhZ3NbaV07XG4gICAgICAgICAgICBpZiAoZmxhZyAhPSBudWxsKSByZXNbZmxhZ10gPSAhISh2YWwgJiAxIDw8IGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuc2l6ZSgpO1xuICAgIH1cbiAgICBlbmNvZGUoc3RyZWFtLCBrZXlzKSB7XG4gICAgICAgIGxldCB2YWwgPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5mbGFncy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBmbGFnID0gdGhpcy5mbGFnc1tpXTtcbiAgICAgICAgICAgIGlmIChmbGFnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5c1tmbGFnXSkgdmFsIHw9IDEgPDwgaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50eXBlLmVuY29kZShzdHJlYW0sIHZhbCk7XG4gICAgfVxufVxuXG5cblxuY2xhc3MgJDg0MTVlOTFiYjgzZmFmNzQkZXhwb3J0JGZmODg3Y2VmZWU0ZDYxZWMgZXh0ZW5kcyAoMCwgJDhkMjFmN2ZhNTg4MDI5MDEkZXhwb3J0JGVmODhhYTBkMzRjMzQ1MjApIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgZGVjb2RlKHN0cmVhbSwgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMudHlwZS5kZWNvZGUoc3RyZWFtLCBwYXJlbnQpO1xuICAgIH1cbiAgICBzaXplKHZhbCwgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuc2l6ZSh2YWwsIHBhcmVudCk7XG4gICAgfVxuICAgIGVuY29kZShzdHJlYW0sIHZhbCwgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuZW5jb2RlKHN0cmVhbSwgK3ZhbCwgcGFyZW50KTtcbiAgICB9XG59XG5cblxuXG5cblxuY2xhc3MgJDA4ZDI4NjA0MTE5YWY0N2UkZXhwb3J0JDdkMjJhMGVlYTY2NTY0NzQgZXh0ZW5kcyAoMCwgJDhkMjFmN2ZhNTg4MDI5MDEkZXhwb3J0JGVmODhhYTBkMzRjMzQ1MjApIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgZGVjb2RlKHN0cmVhbSwgcGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICQ0NTU5ZWNmOTQwZWRjNzhkJGV4cG9ydCQ4M2I2ZGMzNTAzYzFmZGE2KHRoaXMubGVuZ3RoLCBzdHJlYW0sIHBhcmVudCk7XG4gICAgICAgIHJldHVybiBzdHJlYW0ucmVhZEJ1ZmZlcihsZW5ndGgpO1xuICAgIH1cbiAgICBzaXplKHZhbCwgcGFyZW50KSB7XG4gICAgICAgIGlmICghdmFsKSByZXR1cm4gJDQ1NTllY2Y5NDBlZGM3OGQkZXhwb3J0JDgzYjZkYzM1MDNjMWZkYTYodGhpcy5sZW5ndGgsIG51bGwsIHBhcmVudCk7XG4gICAgICAgIGxldCBsZW4gPSB2YWwubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggaW5zdGFuY2VvZiAoMCwgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGZmZmE2N2U1MTVkMDQwMjIpKSBsZW4gKz0gdGhpcy5sZW5ndGguc2l6ZSgpO1xuICAgICAgICByZXR1cm4gbGVuO1xuICAgIH1cbiAgICBlbmNvZGUoc3RyZWFtLCBidWYsIHBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggaW5zdGFuY2VvZiAoMCwgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGZmZmE2N2U1MTVkMDQwMjIpKSB0aGlzLmxlbmd0aC5lbmNvZGUoc3RyZWFtLCBidWYubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS53cml0ZUJ1ZmZlcihidWYpO1xuICAgIH1cbn1cblxuXG5cbmNsYXNzICQwNzBjZTMxZWE5NDc0NjdmJGV4cG9ydCRkZWI4MjUwOGRkNjZkMjg4IGV4dGVuZHMgKDAsICQ4ZDIxZjdmYTU4ODAyOTAxJGV4cG9ydCRlZjg4YWEwZDM0YzM0NTIwKSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IFtdKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgZGVjb2RlKHN0cmVhbSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMudHlwZS5kZWNvZGUoc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1tpbmRleF0gfHwgaW5kZXg7XG4gICAgfVxuICAgIHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuc2l6ZSgpO1xuICAgIH1cbiAgICBlbmNvZGUoc3RyZWFtLCB2YWwpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm9wdGlvbnMuaW5kZXhPZih2YWwpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3B0aW9uIGluIGVudW06ICR7dmFsfWApO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLmVuY29kZShzdHJlYW0sIGluZGV4KTtcbiAgICB9XG59XG5cblxuXG5jbGFzcyAkODA3MDM1NDJmY2ZiNmZmMCRleHBvcnQkN2FjYjdiMjRjNDc4ZjljNiBleHRlbmRzICgwLCAkOGQyMWY3ZmE1ODgwMjkwMSRleHBvcnQkZWY4OGFhMGQzNGMzNDUyMCkge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGNvbmRpdGlvbiA9IHRydWUpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICB9XG4gICAgZGVjb2RlKHN0cmVhbSwgcGFyZW50KSB7XG4gICAgICAgIGxldCB7IGNvbmRpdGlvbjogY29uZGl0aW9uICB9ID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBjb25kaXRpb24gPT09IFwiZnVuY3Rpb25cIikgY29uZGl0aW9uID0gY29uZGl0aW9uLmNhbGwocGFyZW50LCBwYXJlbnQpO1xuICAgICAgICBpZiAoY29uZGl0aW9uKSByZXR1cm4gdGhpcy50eXBlLmRlY29kZShzdHJlYW0sIHBhcmVudCk7XG4gICAgfVxuICAgIHNpemUodmFsLCBwYXJlbnQpIHtcbiAgICAgICAgbGV0IHsgY29uZGl0aW9uOiBjb25kaXRpb24gIH0gPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmRpdGlvbiA9PT0gXCJmdW5jdGlvblwiKSBjb25kaXRpb24gPSBjb25kaXRpb24uY2FsbChwYXJlbnQsIHBhcmVudCk7XG4gICAgICAgIGlmIChjb25kaXRpb24pIHJldHVybiB0aGlzLnR5cGUuc2l6ZSh2YWwsIHBhcmVudCk7XG4gICAgICAgIGVsc2UgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVuY29kZShzdHJlYW0sIHZhbCwgcGFyZW50KSB7XG4gICAgICAgIGxldCB7IGNvbmRpdGlvbjogY29uZGl0aW9uICB9ID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBjb25kaXRpb24gPT09IFwiZnVuY3Rpb25cIikgY29uZGl0aW9uID0gY29uZGl0aW9uLmNhbGwocGFyZW50LCBwYXJlbnQpO1xuICAgICAgICBpZiAoY29uZGl0aW9uKSByZXR1cm4gdGhpcy50eXBlLmVuY29kZShzdHJlYW0sIHZhbCwgcGFyZW50KTtcbiAgICB9XG59XG5cblxuXG5cbmNsYXNzICRmNGZkNDk4NzgyMzI1MDhhJGV4cG9ydCRkYTliNWZlMTg3YTlhYTEgZXh0ZW5kcyAoMCwgJDhkMjFmN2ZhNTg4MDI5MDEkZXhwb3J0JGVmODhhYTBkMzRjMzQ1MjApIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBjb3VudCA9IDEpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgfVxuICAgIGRlY29kZShzdHJlYW0sIHBhcmVudCkge1xuICAgICAgICBzdHJlYW0ucG9zICs9IHRoaXMuc2l6ZShudWxsLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzaXplKGRhdGEsIHBhcmVudCkge1xuICAgICAgICBjb25zdCBjb3VudCA9ICQ0NTU5ZWNmOTQwZWRjNzhkJGV4cG9ydCQ4M2I2ZGMzNTAzYzFmZGE2KHRoaXMuY291bnQsIG51bGwsIHBhcmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuc2l6ZSgpICogY291bnQ7XG4gICAgfVxuICAgIGVuY29kZShzdHJlYW0sIHZhbCwgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uZmlsbCgwLCB0aGlzLnNpemUodmFsLCBwYXJlbnQpKTtcbiAgICB9XG59XG5cblxuXG5cblxuY2xhc3MgJGQ4NzA1Y2Q0MDIyZTdkY2YkZXhwb3J0JDg5YjhlMGZhNjVmNmE5MTQgZXh0ZW5kcyAoMCwgJDhkMjFmN2ZhNTg4MDI5MDEkZXhwb3J0JGVmODhhYTBkMzRjMzQ1MjApIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGVuY29kaW5nID0gXCJhc2NpaVwiKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB9XG4gICAgZGVjb2RlKHN0cmVhbSwgcGFyZW50KSB7XG4gICAgICAgIGxldCBsZW5ndGgsIHBvcztcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9IG51bGwpIGxlbmd0aCA9ICQ0NTU5ZWNmOTQwZWRjNzhkJGV4cG9ydCQ4M2I2ZGMzNTAzYzFmZGE2KHRoaXMubGVuZ3RoLCBzdHJlYW0sIHBhcmVudCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJ1ZmZlcjtcbiAgICAgICAgICAgICh7IGJ1ZmZlcjogYnVmZmVyICwgbGVuZ3RoOiBsZW5ndGggLCBwb3M6IHBvcyAgfSA9IHN0cmVhbSk7XG4gICAgICAgICAgICB3aGlsZShwb3MgPCBsZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09IDB4MDApKytwb3M7XG4gICAgICAgICAgICBsZW5ndGggPSBwb3MgLSBzdHJlYW0ucG9zO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGVuY29kaW5nOiBlbmNvZGluZyAgfSA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09IFwiZnVuY3Rpb25cIikgZW5jb2RpbmcgPSBlbmNvZGluZy5jYWxsKHBhcmVudCwgcGFyZW50KSB8fCBcImFzY2lpXCI7XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IHN0cmVhbS5yZWFkU3RyaW5nKGxlbmd0aCwgZW5jb2RpbmcpO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT0gbnVsbCAmJiBzdHJlYW0ucG9zIDwgc3RyZWFtLmxlbmd0aCkgc3RyZWFtLnBvcysrO1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cbiAgICBzaXplKHZhbCwgcGFyZW50KSB7XG4gICAgICAgIC8vIFVzZSB0aGUgZGVmaW5lZCB2YWx1ZSBpZiBubyB2YWx1ZSB3YXMgZ2l2ZW5cbiAgICAgICAgaWYgKCF2YWwpIHJldHVybiAkNDU1OWVjZjk0MGVkYzc4ZCRleHBvcnQkODNiNmRjMzUwM2MxZmRhNih0aGlzLmxlbmd0aCwgbnVsbCwgcGFyZW50KTtcbiAgICAgICAgbGV0IHsgZW5jb2Rpbmc6IGVuY29kaW5nICB9ID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gXCJmdW5jdGlvblwiKSBlbmNvZGluZyA9IGVuY29kaW5nLmNhbGwocGFyZW50ICE9IG51bGwgPyBwYXJlbnQudmFsIDogdW5kZWZpbmVkLCBwYXJlbnQgIT0gbnVsbCA/IHBhcmVudC52YWwgOiB1bmRlZmluZWQpIHx8IFwiYXNjaWlcIjtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSBcInV0ZjE2YmVcIikgZW5jb2RpbmcgPSBcInV0ZjE2bGVcIjtcbiAgICAgICAgbGV0IHNpemUgPSAkZDg3MDVjZDQwMjJlN2RjZiR2YXIkYnl0ZUxlbmd0aCh2YWwsIGVuY29kaW5nKTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIGluc3RhbmNlb2YgKDAsICRhZjY1YWJmN2JmNjVhYzQyJGV4cG9ydCRmZmZhNjdlNTE1ZDA0MDIyKSkgc2l6ZSArPSB0aGlzLmxlbmd0aC5zaXplKCk7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSBudWxsKSBzaXplKys7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICBlbmNvZGUoc3RyZWFtLCB2YWwsIHBhcmVudCkge1xuICAgICAgICBsZXQgeyBlbmNvZGluZzogZW5jb2RpbmcgIH0gPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSBcImZ1bmN0aW9uXCIpIGVuY29kaW5nID0gZW5jb2RpbmcuY2FsbChwYXJlbnQgIT0gbnVsbCA/IHBhcmVudC52YWwgOiB1bmRlZmluZWQsIHBhcmVudCAhPSBudWxsID8gcGFyZW50LnZhbCA6IHVuZGVmaW5lZCkgfHwgXCJhc2NpaVwiO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggaW5zdGFuY2VvZiAoMCwgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0JGZmZmE2N2U1MTVkMDQwMjIpKSB0aGlzLmxlbmd0aC5lbmNvZGUoc3RyZWFtLCAkZDg3MDVjZDQwMjJlN2RjZiR2YXIkYnl0ZUxlbmd0aCh2YWwsIGVuY29kaW5nKSk7XG4gICAgICAgIHN0cmVhbS53cml0ZVN0cmluZyh2YWwsIGVuY29kaW5nKTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09IG51bGwpIHJldHVybiBzdHJlYW0ud3JpdGVVSW50OCgweDAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkZDg3MDVjZDQwMjJlN2RjZiR2YXIkYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB7XG4gICAgc3dpdGNoKGVuY29kaW5nKXtcbiAgICAgICAgY2FzZSBcImFzY2lpXCI6XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYgJiYgaSA8IHN0cmluZy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjMiA9IHN0cmluZy5jaGFyQ29kZUF0KCsraSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIGMgPSAoKGMgJiAweDNmZikgPDwgMTApICsgKGMyICYgMHgzZmYpICsgMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSAvLyB1bm1hdGNoZWQgc3Vycm9nYXRlLlxuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoYyAmIDB4ZmZmZmZmODApID09PSAwKSBsZW4rKztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmZmZmY4MDApID09PSAwKSBsZW4gKz0gMjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmZmZjAwMDApID09PSAwKSBsZW4gKz0gMztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmZlMDAwMDApID09PSAwKSBsZW4gKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgIGNhc2UgXCJ1dGYxNi1sZVwiOlxuICAgICAgICBjYXNlIFwidXRmMTZiZVwiOlxuICAgICAgICBjYXNlIFwidXRmMTYtYmVcIjpcbiAgICAgICAgY2FzZSBcInVjczJcIjpcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoICogMjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2RpbmcgXCIgKyBlbmNvZGluZyk7XG4gICAgfVxufVxuXG5cblxuXG5jbGFzcyAkYWE4YjY2YmFlNmFiZTY1OCRleHBvcnQkZWFiYzcxZjAxMWRmNjc1YSBleHRlbmRzICgwLCAkOGQyMWY3ZmE1ODgwMjkwMSRleHBvcnQkZWY4OGFhMGQzNGMzNDUyMCkge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcyA9IHt9KXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgfVxuICAgIGRlY29kZShzdHJlYW0sIHBhcmVudCwgbGVuZ3RoID0gMCkge1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLl9zZXR1cChzdHJlYW0sIHBhcmVudCwgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fcGFyc2VGaWVsZHMoc3RyZWFtLCByZXMsIHRoaXMuZmllbGRzKTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2VzcyAhPSBudWxsKSB0aGlzLnByb2Nlc3MuY2FsbChyZXMsIHN0cmVhbSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9zZXR1cChzdHJlYW0sIHBhcmVudCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICAvLyBkZWZpbmUgaGlkZGVuIHByb3BlcnRpZXNcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocmVzLCB7XG4gICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyZW50XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3N0YXJ0T2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0cmVhbS5wb3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY3VycmVudE9mZnNldDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2xlbmd0aDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsZW5ndGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9wYXJzZUZpZWxkcyhzdHJlYW0sIHJlcywgZmllbGRzKSB7XG4gICAgICAgIGZvcihsZXQga2V5IGluIGZpZWxkcyl7XG4gICAgICAgICAgICB2YXIgdmFsO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGZpZWxkc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpIHZhbCA9IHR5cGUuY2FsbChyZXMsIHJlcyk7XG4gICAgICAgICAgICBlbHNlIHZhbCA9IHR5cGUuZGVjb2RlKHN0cmVhbSwgcmVzKTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiAkNDU1OWVjZjk0MGVkYzc4ZCRleHBvcnQkNDE3MDViMWQ2NDRlMGYxNCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcywga2V5LCB2YWwpO1xuICAgICAgICAgICAgICAgIGVsc2UgcmVzW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMuX2N1cnJlbnRPZmZzZXQgPSBzdHJlYW0ucG9zIC0gcmVzLl9zdGFydE9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaXplKHZhbCwgcGFyZW50LCBpbmNsdWRlUG9pbnRlcnMgPSB0cnVlKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkgdmFsID0ge307XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICBwb2ludGVyU2l6ZTogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcmVFbmNvZGUgIT0gbnVsbCkgdGhpcy5wcmVFbmNvZGUuY2FsbCh2YWwpO1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGZvcihsZXQga2V5IGluIHRoaXMuZmllbGRzKXtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmZpZWxkc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGUuc2l6ZSAhPSBudWxsKSBzaXplICs9IHR5cGUuc2l6ZSh2YWxba2V5XSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZVBvaW50ZXJzKSBzaXplICs9IGN0eC5wb2ludGVyU2l6ZTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIGVuY29kZShzdHJlYW0sIHZhbCwgcGFyZW50KSB7XG4gICAgICAgIGxldCB0eXBlO1xuICAgICAgICBpZiAodGhpcy5wcmVFbmNvZGUgIT0gbnVsbCkgdGhpcy5wcmVFbmNvZGUuY2FsbCh2YWwsIHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBbXSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdHJlYW0ucG9zLFxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgICAgIHBvaW50ZXJTaXplOiAwXG4gICAgICAgIH07XG4gICAgICAgIGN0eC5wb2ludGVyT2Zmc2V0ID0gc3RyZWFtLnBvcyArIHRoaXMuc2l6ZSh2YWwsIGN0eCwgZmFsc2UpO1xuICAgICAgICBmb3IobGV0IGtleSBpbiB0aGlzLmZpZWxkcyl7XG4gICAgICAgICAgICB0eXBlID0gdGhpcy5maWVsZHNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlLmVuY29kZSAhPSBudWxsKSB0eXBlLmVuY29kZShzdHJlYW0sIHZhbFtrZXldLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUoaSA8IGN0eC5wb2ludGVycy5sZW5ndGgpe1xuICAgICAgICAgICAgY29uc3QgcHRyID0gY3R4LnBvaW50ZXJzW2krK107XG4gICAgICAgICAgICBwdHIudHlwZS5lbmNvZGUoc3RyZWFtLCBwdHIudmFsLCBwdHIucGFyZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbmNvbnN0ICRmY2IyMDhhOTVmNmQwNDhiJHZhciRnZXRQYXRoID0gKG9iamVjdCwgcGF0aEFycmF5KT0+e1xuICAgIHJldHVybiBwYXRoQXJyYXkucmVkdWNlKChwcmV2T2JqLCBrZXkpPT5wcmV2T2JqICYmIHByZXZPYmpba2V5XSwgb2JqZWN0KTtcbn07XG5jbGFzcyAkZmNiMjA4YTk1ZjZkMDQ4YiRleHBvcnQkOTVhOGI2MGY0ZGE3ZGVjOCBleHRlbmRzICgwLCAkYWE4YjY2YmFlNmFiZTY1OCRleHBvcnQkZWFiYzcxZjAxMWRmNjc1YSkge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHZlcnNpb25zID0ge30pe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZlcnNpb25zID0gdmVyc2lvbnM7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIikgdGhpcy52ZXJzaW9uUGF0aCA9IHR5cGUuc3BsaXQoXCIuXCIpO1xuICAgIH1cbiAgICBkZWNvZGUoc3RyZWFtLCBwYXJlbnQsIGxlbmd0aCA9IDApIHtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5fc2V0dXAoc3RyZWFtLCBwYXJlbnQsIGxlbmd0aCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50eXBlID09PSBcInN0cmluZ1wiKSByZXMudmVyc2lvbiA9ICRmY2IyMDhhOTVmNmQwNDhiJHZhciRnZXRQYXRoKHBhcmVudCwgdGhpcy52ZXJzaW9uUGF0aCk7XG4gICAgICAgIGVsc2UgcmVzLnZlcnNpb24gPSB0aGlzLnR5cGUuZGVjb2RlKHN0cmVhbSk7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb25zLmhlYWRlcikgdGhpcy5fcGFyc2VGaWVsZHMoc3RyZWFtLCByZXMsIHRoaXMudmVyc2lvbnMuaGVhZGVyKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy52ZXJzaW9uc1tyZXMudmVyc2lvbl07XG4gICAgICAgIGlmIChmaWVsZHMgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHZlcnNpb24gJHtyZXMudmVyc2lvbn1gKTtcbiAgICAgICAgaWYgKGZpZWxkcyBpbnN0YW5jZW9mICRmY2IyMDhhOTVmNmQwNDhiJGV4cG9ydCQ5NWE4YjYwZjRkYTdkZWM4KSByZXR1cm4gZmllbGRzLmRlY29kZShzdHJlYW0sIHBhcmVudCk7XG4gICAgICAgIHRoaXMuX3BhcnNlRmllbGRzKHN0cmVhbSwgcmVzLCBmaWVsZHMpO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzICE9IG51bGwpIHRoaXMucHJvY2Vzcy5jYWxsKHJlcywgc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc2l6ZSh2YWwsIHBhcmVudCwgaW5jbHVkZVBvaW50ZXJzID0gdHJ1ZSkge1xuICAgICAgICBsZXQga2V5LCB0eXBlO1xuICAgICAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgZml4ZWQgc2l6ZVwiKTtcbiAgICAgICAgaWYgKHRoaXMucHJlRW5jb2RlICE9IG51bGwpIHRoaXMucHJlRW5jb2RlLmNhbGwodmFsKTtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgICAgIHBvaW50ZXJTaXplOiAwXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnR5cGUgIT09IFwic3RyaW5nXCIpIHNpemUgKz0gdGhpcy50eXBlLnNpemUodmFsLnZlcnNpb24sIGN0eCk7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb25zLmhlYWRlcikgZm9yKGtleSBpbiB0aGlzLnZlcnNpb25zLmhlYWRlcil7XG4gICAgICAgICAgICB0eXBlID0gdGhpcy52ZXJzaW9ucy5oZWFkZXJba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlLnNpemUgIT0gbnVsbCkgc2l6ZSArPSB0eXBlLnNpemUodmFsW2tleV0sIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy52ZXJzaW9uc1t2YWwudmVyc2lvbl07XG4gICAgICAgIGlmIChmaWVsZHMgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHZlcnNpb24gJHt2YWwudmVyc2lvbn1gKTtcbiAgICAgICAgZm9yKGtleSBpbiBmaWVsZHMpe1xuICAgICAgICAgICAgdHlwZSA9IGZpZWxkc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGUuc2l6ZSAhPSBudWxsKSBzaXplICs9IHR5cGUuc2l6ZSh2YWxba2V5XSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZVBvaW50ZXJzKSBzaXplICs9IGN0eC5wb2ludGVyU2l6ZTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIGVuY29kZShzdHJlYW0sIHZhbCwgcGFyZW50KSB7XG4gICAgICAgIGxldCBrZXksIHR5cGU7XG4gICAgICAgIGlmICh0aGlzLnByZUVuY29kZSAhPSBudWxsKSB0aGlzLnByZUVuY29kZS5jYWxsKHZhbCwgc3RyZWFtKTtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgcG9pbnRlcnM6IFtdLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHN0cmVhbS5wb3MsXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgIHZhbDogdmFsLFxuICAgICAgICAgICAgcG9pbnRlclNpemU6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY3R4LnBvaW50ZXJPZmZzZXQgPSBzdHJlYW0ucG9zICsgdGhpcy5zaXplKHZhbCwgY3R4LCBmYWxzZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50eXBlICE9PSBcInN0cmluZ1wiKSB0aGlzLnR5cGUuZW5jb2RlKHN0cmVhbSwgdmFsLnZlcnNpb24pO1xuICAgICAgICBpZiAodGhpcy52ZXJzaW9ucy5oZWFkZXIpIGZvcihrZXkgaW4gdGhpcy52ZXJzaW9ucy5oZWFkZXIpe1xuICAgICAgICAgICAgdHlwZSA9IHRoaXMudmVyc2lvbnMuaGVhZGVyW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZS5lbmNvZGUgIT0gbnVsbCkgdHlwZS5lbmNvZGUoc3RyZWFtLCB2YWxba2V5XSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnZlcnNpb25zW3ZhbC52ZXJzaW9uXTtcbiAgICAgICAgZm9yKGtleSBpbiBmaWVsZHMpe1xuICAgICAgICAgICAgdHlwZSA9IGZpZWxkc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGUuZW5jb2RlICE9IG51bGwpIHR5cGUuZW5jb2RlKHN0cmVhbSwgdmFsW2tleV0sIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZShpIDwgY3R4LnBvaW50ZXJzLmxlbmd0aCl7XG4gICAgICAgICAgICBjb25zdCBwdHIgPSBjdHgucG9pbnRlcnNbaSsrXTtcbiAgICAgICAgICAgIHB0ci50eXBlLmVuY29kZShzdHJlYW0sIHB0ci52YWwsIHB0ci5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuXG52YXIgJDkyMTg0OTYyZjhmMGQ1ZTIkZXhwb3J0cyA9IHt9O1xuXG4kcGFyY2VsJGV4cG9ydCgkOTIxODQ5NjJmOGYwZDVlMiRleHBvcnRzLCBcIlBvaW50ZXJcIiwgKCkgPT4gJDkyMTg0OTYyZjhmMGQ1ZTIkZXhwb3J0JGI1NjAwN2YxMmVkZjBjMTcpO1xuJHBhcmNlbCRleHBvcnQoJDkyMTg0OTYyZjhmMGQ1ZTIkZXhwb3J0cywgXCJWb2lkUG9pbnRlclwiLCAoKSA9PiAkOTIxODQ5NjJmOGYwZDVlMiRleHBvcnQkZGY1Y2IxZjNkMDRmNWEwZik7XG5cblxuY2xhc3MgJDkyMTg0OTYyZjhmMGQ1ZTIkZXhwb3J0JGI1NjAwN2YxMmVkZjBjMTcgZXh0ZW5kcyAoMCwgJDhkMjFmN2ZhNTg4MDI5MDEkZXhwb3J0JGVmODhhYTBkMzRjMzQ1MjApIHtcbiAgICBjb25zdHJ1Y3RvcihvZmZzZXRUeXBlLCB0eXBlLCBvcHRpb25zID0ge30pe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9mZnNldFR5cGUgPSBvZmZzZXRUeXBlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcInZvaWRcIikgdGhpcy50eXBlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09IG51bGwpIHRoaXMub3B0aW9ucy50eXBlID0gXCJsb2NhbFwiO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93TnVsbCA9PSBudWxsKSB0aGlzLm9wdGlvbnMuYWxsb3dOdWxsID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5udWxsVmFsdWUgPT0gbnVsbCkgdGhpcy5vcHRpb25zLm51bGxWYWx1ZSA9IDA7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF6eSA9PSBudWxsKSB0aGlzLm9wdGlvbnMubGF6eSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlbGF0aXZlVG8pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnJlbGF0aXZlVG8gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwicmVsYXRpdmVUbyBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRvR2V0dGVyID0gb3B0aW9ucy5yZWxhdGl2ZVRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29kZShzdHJlYW0sIGN0eCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldFR5cGUuZGVjb2RlKHN0cmVhbSwgY3R4KTtcbiAgICAgICAgLy8gaGFuZGxlIE5VTEwgcG9pbnRlcnNcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdGhpcy5vcHRpb25zLm51bGxWYWx1ZSAmJiB0aGlzLm9wdGlvbnMuYWxsb3dOdWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHJlbGF0aXZlO1xuICAgICAgICBzd2l0Y2godGhpcy5vcHRpb25zLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSBcImxvY2FsXCI6XG4gICAgICAgICAgICAgICAgcmVsYXRpdmUgPSBjdHguX3N0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImltbWVkaWF0ZVwiOlxuICAgICAgICAgICAgICAgIHJlbGF0aXZlID0gc3RyZWFtLnBvcyAtIHRoaXMub2Zmc2V0VHlwZS5zaXplKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicGFyZW50XCI6XG4gICAgICAgICAgICAgICAgcmVsYXRpdmUgPSBjdHgucGFyZW50Ll9zdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBjdHg7XG4gICAgICAgICAgICAgICAgd2hpbGUoYy5wYXJlbnQpYyA9IGMucGFyZW50O1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlID0gYy5fc3RhcnRPZmZzZXQgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlbGF0aXZlVG8pIHJlbGF0aXZlICs9IHRoaXMucmVsYXRpdmVUb0dldHRlcihjdHgpO1xuICAgICAgICBjb25zdCBwdHIgPSBvZmZzZXQgKyByZWxhdGl2ZTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZVZhbHVlID0gKCk9PntcbiAgICAgICAgICAgICAgICBpZiAodmFsICE9IG51bGwpIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwb3M6IHBvcyAgfSA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucG9zID0gcHRyO1xuICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMudHlwZS5kZWNvZGUoc3RyZWFtLCBjdHgpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wb3MgPSBwb3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbGF6eSBwb2ludGVyLCBkZWZpbmUgYSBnZXR0ZXIgdG8gZGVjb2RlIG9ubHkgd2hlbiBuZWVkZWQuXG4gICAgICAgICAgICAvLyBUaGlzIG9idmlvdXNseSBvbmx5IHdvcmtzIHdoZW4gdGhlIHBvaW50ZXIgaXMgY29udGFpbmVkIGJ5IGEgU3RydWN0LlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXp5KSByZXR1cm4gbmV3ICQ0NTU5ZWNmOTQwZWRjNzhkJGV4cG9ydCQ0MTcwNWIxZDY0NGUwZjE0KHtcbiAgICAgICAgICAgICAgICBnZXQ6IGRlY29kZVZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVWYWx1ZSgpO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIHB0cjtcbiAgICB9XG4gICAgc2l6ZSh2YWwsIGN0eCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBjdHg7XG4gICAgICAgIHN3aXRjaCh0aGlzLm9wdGlvbnMudHlwZSl7XG4gICAgICAgICAgICBjYXNlIFwibG9jYWxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpbW1lZGlhdGVcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwYXJlbnRcIjpcbiAgICAgICAgICAgICAgICBjdHggPSBjdHgucGFyZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB3aGlsZShjdHgucGFyZW50KWN0eCA9IGN0eC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgdHlwZTogdHlwZSAgfSA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghKHZhbCBpbnN0YW5jZW9mICQ5MjE4NDk2MmY4ZjBkNWUyJGV4cG9ydCRkZjVjYjFmM2QwNGY1YTBmKSkgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBiZSBhIFZvaWRQb2ludGVyXCIpO1xuICAgICAgICAgICAgKHsgdHlwZTogdHlwZSAgfSA9IHZhbCk7XG4gICAgICAgICAgICB2YWwgPSB2YWwudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCAmJiBjdHgpIHtcbiAgICAgICAgICAgIC8vIE11c3QgYmUgd3JpdHRlbiBhcyB0d28gc2VwYXJhdGUgbGluZXMgcmF0aGVyIHRoYW4gKz0gaW4gY2FzZSBgdHlwZS5zaXplYCBtdXRhdGVzIGN0eC5wb2ludGVyU2l6ZS5cbiAgICAgICAgICAgIGxldCBzaXplID0gdHlwZS5zaXplKHZhbCwgcGFyZW50KTtcbiAgICAgICAgICAgIGN0eC5wb2ludGVyU2l6ZSArPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldFR5cGUuc2l6ZSgpO1xuICAgIH1cbiAgICBlbmNvZGUoc3RyZWFtLCB2YWwsIGN0eCkge1xuICAgICAgICBsZXQgcmVsYXRpdmU7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGN0eDtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldFR5cGUuZW5jb2RlKHN0cmVhbSwgdGhpcy5vcHRpb25zLm51bGxWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKHRoaXMub3B0aW9ucy50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJsb2NhbFwiOlxuICAgICAgICAgICAgICAgIHJlbGF0aXZlID0gY3R4LnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImltbWVkaWF0ZVwiOlxuICAgICAgICAgICAgICAgIHJlbGF0aXZlID0gc3RyZWFtLnBvcyArIHRoaXMub2Zmc2V0VHlwZS5zaXplKHZhbCwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwYXJlbnRcIjpcbiAgICAgICAgICAgICAgICBjdHggPSBjdHgucGFyZW50O1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlID0gY3R4LnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWxhdGl2ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUoY3R4LnBhcmVudCljdHggPSBjdHgucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVsYXRpdmVUbykgcmVsYXRpdmUgKz0gdGhpcy5yZWxhdGl2ZVRvR2V0dGVyKHBhcmVudC52YWwpO1xuICAgICAgICB0aGlzLm9mZnNldFR5cGUuZW5jb2RlKHN0cmVhbSwgY3R4LnBvaW50ZXJPZmZzZXQgLSByZWxhdGl2ZSk7XG4gICAgICAgIGxldCB7IHR5cGU6IHR5cGUgIH0gPSB0aGlzO1xuICAgICAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoISh2YWwgaW5zdGFuY2VvZiAkOTIxODQ5NjJmOGYwZDVlMiRleHBvcnQkZGY1Y2IxZjNkMDRmNWEwZikpIHRocm93IG5ldyBFcnJvcihcIk11c3QgYmUgYSBWb2lkUG9pbnRlclwiKTtcbiAgICAgICAgICAgICh7IHR5cGU6IHR5cGUgIH0gPSB2YWwpO1xuICAgICAgICAgICAgdmFsID0gdmFsLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wb2ludGVycy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3R4LnBvaW50ZXJPZmZzZXQgKz0gdHlwZS5zaXplKHZhbCwgcGFyZW50KTtcbiAgICB9XG59XG5jbGFzcyAkOTIxODQ5NjJmOGYwZDVlMiRleHBvcnQkZGY1Y2IxZjNkMDRmNWEwZiB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgdmFsdWUpe1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuXG5cbiRwYXJjZWwkZXhwb3J0V2lsZGNhcmQobW9kdWxlLmV4cG9ydHMsICQ0NTU5ZWNmOTQwZWRjNzhkJGV4cG9ydHMpO1xuJHBhcmNlbCRleHBvcnRXaWxkY2FyZChtb2R1bGUuZXhwb3J0cywgJGFmNjVhYmY3YmY2NWFjNDIkZXhwb3J0cyk7XG4kcGFyY2VsJGV4cG9ydFdpbGRjYXJkKG1vZHVsZS5leHBvcnRzLCAkOTIxODQ5NjJmOGYwZDVlMiRleHBvcnRzKTtcblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmNqcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/restructure/dist/main.cjs\n");

/***/ })

};
;