"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/immer";
exports.ids = ["vendor-chunks/immer"];
exports.modules = {

/***/ "(ssr)/./node_modules/immer/dist/immer.cjs.development.js":
/*!**********************************************************!*\
  !*** ./node_modules/immer/dist/immer.cjs.development.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar _ref;\n\n// Should be no imports here!\n// Some things that should be evaluated before all else...\n// We only want to know if non-polyfilled symbols are available\nvar hasSymbol = typeof Symbol !== \"undefined\" && typeof\n/*#__PURE__*/\nSymbol(\"x\") === \"symbol\";\nvar hasMap = typeof Map !== \"undefined\";\nvar hasSet = typeof Set !== \"undefined\";\nvar hasProxies = typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\";\n/**\r\n * The sentinel value returned by producers to replace the draft with undefined.\r\n */\n\nvar NOTHING = hasSymbol ?\n/*#__PURE__*/\nSymbol.for(\"immer-nothing\") : (_ref = {}, _ref[\"immer-nothing\"] = true, _ref);\n/**\r\n * To let Immer treat your class instances as plain immutable objects\r\n * (albeit with a custom prototype), you must define either an instance property\r\n * or a static property on each of your custom classes.\r\n *\r\n * Otherwise, your class instance will never be drafted, which means it won't be\r\n * safe to mutate in a produce callback.\r\n */\n\nvar DRAFTABLE = hasSymbol ?\n/*#__PURE__*/\nSymbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = hasSymbol ?\n/*#__PURE__*/\nSymbol.for(\"immer-state\") : \"__$immer_state\"; // Even a polyfilled Symbol might provide Symbol.iterator\n\nvar iteratorSymbol = typeof Symbol != \"undefined\" && Symbol.iterator || \"@@iterator\";\n\nvar errors = {\n  0: \"Illegal state\",\n  1: \"Immer drafts cannot have computed properties\",\n  2: \"This object has been frozen and should not be mutated\",\n  3: function _(data) {\n    return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n  },\n  4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n  5: \"Immer forbids circular references\",\n  6: \"The first or second argument to `produce` must be a function\",\n  7: \"The third argument to `produce` must be a function or undefined\",\n  8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n  9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n  10: \"The given draft is already finalized\",\n  11: \"Object.defineProperty() cannot be used on an Immer draft\",\n  12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n  13: \"Immer only supports deleting array indices\",\n  14: \"Immer only supports setting array indices and the 'length' property\",\n  15: function _(path) {\n    return \"Cannot apply patch, path doesn't resolve: \" + path;\n  },\n  16: 'Sets cannot have \"replace\" patches.',\n  17: function _(op) {\n    return \"Unsupported patch operation: \" + op;\n  },\n  18: function _(plugin) {\n    return \"The plugin for '\" + plugin + \"' has not been loaded into Immer. To enable the plugin, import and call `enable\" + plugin + \"()` when initializing your application.\";\n  },\n  20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n  21: function _(thing) {\n    return \"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\" + thing + \"'\";\n  },\n  22: function _(thing) {\n    return \"'current' expects a draft, got: \" + thing;\n  },\n  23: function _(thing) {\n    return \"'original' expects a draft, got: \" + thing;\n  },\n  24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n};\nfunction die(error) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  {\n    var e = errors[error];\n    var msg = !e ? \"unknown error nr: \" + error : typeof e === \"function\" ? e.apply(null, args) : e;\n    throw new Error(\"[Immer] \" + msg);\n  }\n}\n\n/** Returns true if the given value is an Immer draft */\n\n/*#__PURE__*/\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n/** Returns true if the given value can be drafted by Immer */\n\n/*#__PURE__*/\n\nfunction isDraftable(value) {\n  var _value$constructor;\n\n  if (!value) return false;\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);\n}\nvar objectCtorString =\n/*#__PURE__*/\nObject.prototype.constructor.toString();\n/*#__PURE__*/\n\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") return false;\n  var proto = Object.getPrototypeOf(value);\n\n  if (proto === null) {\n    return true;\n  }\n\n  var Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  if (Ctor === Object) return true;\n  return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\nfunction original(value) {\n  if (!isDraft(value)) die(23, value);\n  return value[DRAFT_STATE].base_;\n}\n/*#__PURE__*/\n\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} :\n/* istanbul ignore next */\nObject.getOwnPropertyNames;\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {\n  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n  var res = {};\n  ownKeys(target).forEach(function (key) {\n    res[key] = Object.getOwnPropertyDescriptor(target, key);\n  });\n  return res;\n};\nfunction each(obj, iter, enumerableOnly) {\n  if (enumerableOnly === void 0) {\n    enumerableOnly = false;\n  }\n\n  if (getArchtype(obj) === 0\n  /* Object */\n  ) {\n      (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function (key) {\n        if (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj);\n      });\n    } else {\n    obj.forEach(function (entry, index) {\n      return iter(index, entry, obj);\n    });\n  }\n}\n/*#__PURE__*/\n\nfunction getArchtype(thing) {\n  /* istanbul ignore next */\n  var state = thing[DRAFT_STATE];\n  return state ? state.type_ > 3 ? state.type_ - 4 // cause Object and Array map back from 4 and 5\n  : state.type_ // others are the same\n  : Array.isArray(thing) ? 1\n  /* Array */\n  : isMap(thing) ? 2\n  /* Map */\n  : isSet(thing) ? 3\n  /* Set */\n  : 0\n  /* Object */\n  ;\n}\n/*#__PURE__*/\n\nfunction has(thing, prop) {\n  return getArchtype(thing) === 2\n  /* Map */\n  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\n/*#__PURE__*/\n\nfunction get(thing, prop) {\n  // @ts-ignore\n  return getArchtype(thing) === 2\n  /* Map */\n  ? thing.get(prop) : thing[prop];\n}\n/*#__PURE__*/\n\nfunction set(thing, propOrOldValue, value) {\n  var t = getArchtype(thing);\n  if (t === 2\n  /* Map */\n  ) thing.set(propOrOldValue, value);else if (t === 3\n  /* Set */\n  ) {\n      thing.add(value);\n    } else thing[propOrOldValue] = value;\n}\n/*#__PURE__*/\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n/*#__PURE__*/\n\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\n/*#__PURE__*/\n\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\n/*#__PURE__*/\n\nfunction latest(state) {\n  return state.copy_ || state.base_;\n}\n/*#__PURE__*/\n\nfunction shallowCopy(base) {\n  if (Array.isArray(base)) return Array.prototype.slice.call(base);\n  var descriptors = getOwnPropertyDescriptors(base);\n  delete descriptors[DRAFT_STATE];\n  var keys = ownKeys(descriptors);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var desc = descriptors[key];\n\n    if (desc.writable === false) {\n      desc.writable = true;\n      desc.configurable = true;\n    } // like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n    // with libraries that trap values, like mobx or vue\n    // unlike object.assign, non-enumerables will be copied as well\n\n\n    if (desc.get || desc.set) descriptors[key] = {\n      configurable: true,\n      writable: true,\n      enumerable: desc.enumerable,\n      value: base[key]\n    };\n  }\n\n  return Object.create(Object.getPrototypeOf(base), descriptors);\n}\nfunction freeze(obj, deep) {\n  if (deep === void 0) {\n    deep = false;\n  }\n\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\n\n  if (getArchtype(obj) > 1\n  /* Map or Set */\n  ) {\n      obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n    }\n\n  Object.freeze(obj);\n  if (deep) each(obj, function (key, value) {\n    return freeze(value, true);\n  }, true);\n  return obj;\n}\n\nfunction dontMutateFrozenCollections() {\n  die(2);\n}\n\nfunction isFrozen(obj) {\n  if (obj == null || typeof obj !== \"object\") return true; // See #600, IE dies on non-objects in Object.isFrozen\n\n  return Object.isFrozen(obj);\n}\n\n/** Plugin utilities */\n\nvar plugins = {};\nfunction getPlugin(pluginKey) {\n  var plugin = plugins[pluginKey];\n\n  if (!plugin) {\n    die(18, pluginKey);\n  } // @ts-ignore\n\n\n  return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n  if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\n}\n\nvar currentScope;\nfunction getCurrentScope() {\n  if ( !currentScope) die(0);\n  return currentScope;\n}\n\nfunction createScope(parent_, immer_) {\n  return {\n    drafts_: [],\n    parent_: parent_,\n    immer_: immer_,\n    // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n    canAutoFreeze_: true,\n    unfinalizedDrafts_: 0\n  };\n}\n\nfunction usePatchesInScope(scope, patchListener) {\n  if (patchListener) {\n    getPlugin(\"Patches\"); // assert we have the plugin\n\n    scope.patches_ = [];\n    scope.inversePatches_ = [];\n    scope.patchListener_ = patchListener;\n  }\n}\nfunction revokeScope(scope) {\n  leaveScope(scope);\n  scope.drafts_.forEach(revokeDraft); // @ts-ignore\n\n  scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n  if (scope === currentScope) {\n    currentScope = scope.parent_;\n  }\n}\nfunction enterScope(immer) {\n  return currentScope = createScope(currentScope, immer);\n}\n\nfunction revokeDraft(draft) {\n  var state = draft[DRAFT_STATE];\n  if (state.type_ === 0\n  /* ProxyObject */\n  || state.type_ === 1\n  /* ProxyArray */\n  ) state.revoke_();else state.revoked_ = true;\n}\n\nfunction processResult(result, scope) {\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\n  var baseDraft = scope.drafts_[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  if (!scope.immer_.useProxies_) getPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified_) {\n      revokeScope(scope);\n      die(4);\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = finalize(scope, result);\n      if (!scope.parent_) maybeFreeze(scope, result);\n    }\n\n    if (scope.patches_) {\n      getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);\n    }\n  } else {\n    // Finalize the base draft.\n    result = finalize(scope, baseDraft, []);\n  }\n\n  revokeScope(scope);\n\n  if (scope.patches_) {\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\n  }\n\n  return result !== NOTHING ? result : undefined;\n}\n\nfunction finalize(rootScope, value, path) {\n  // Don't recurse in tho recursive data structures\n  if (isFrozen(value)) return value;\n  var state = value[DRAFT_STATE]; // A plain object, might need freezing, might contain drafts\n\n  if (!state) {\n    each(value, function (key, childValue) {\n      return finalizeProperty(rootScope, state, value, key, childValue, path);\n    }, true // See #590, don't recurse into non-enumerable of non drafted objects\n    );\n    return value;\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope_ !== rootScope) return value; // Unmodified draft, return the (frozen) original\n\n  if (!state.modified_) {\n    maybeFreeze(rootScope, state.base_, true);\n    return state.base_;\n  } // Not finalized yet, let's do that now\n\n\n  if (!state.finalized_) {\n    state.finalized_ = true;\n    state.scope_.unfinalizedDrafts_--;\n    var result = // For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n    state.type_ === 4\n    /* ES5Object */\n    || state.type_ === 5\n    /* ES5Array */\n    ? state.copy_ = shallowCopy(state.draft_) : state.copy_; // Finalize all children of the copy\n    // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n    // To preserve insertion order in all cases we then clear the set\n    // And we let finalizeProperty know it needs to re-add non-draft children back to the target\n\n    var resultEach = result;\n    var isSet = false;\n\n    if (state.type_ === 3\n    /* Set */\n    ) {\n        resultEach = new Set(result);\n        result.clear();\n        isSet = true;\n      }\n\n    each(resultEach, function (key, childValue) {\n      return finalizeProperty(rootScope, state, result, key, childValue, path, isSet);\n    }); // everything inside is frozen, we can freeze here\n\n    maybeFreeze(rootScope, result, false); // first time finalizing, let's create those patches\n\n    if (path && rootScope.patches_) {\n      getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);\n    }\n  }\n\n  return state.copy_;\n}\n\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n  if ( childValue === targetObject) die(5);\n\n  if (isDraft(childValue)) {\n    var path = rootPath && parentState && parentState.type_ !== 3\n    /* Set */\n    && // Set objects are atomic since they have no keys.\n    !has(parentState.assigned_, prop) // Skip deep patches for assigned keys.\n    ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.\n\n    var res = finalize(rootScope, childValue, path);\n    set(targetObject, prop, res); // Drafts from another scope must prevented to be frozen\n    // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\n    if (isDraft(res)) {\n      rootScope.canAutoFreeze_ = false;\n    } else return;\n  } else if (targetIsSet) {\n    targetObject.add(childValue);\n  } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\n\n  if (isDraftable(childValue) && !isFrozen(childValue)) {\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n      // optimization: if an object is not a draft, and we don't have to\n      // deepfreeze everything, and we are sure that no drafts are left in the remaining object\n      // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n      // This benefits especially adding large data tree's without further processing.\n      // See add-data.js perf test\n      return;\n    }\n\n    finalize(rootScope, childValue); // immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\n    if (!parentState || !parentState.scope_.parent_) maybeFreeze(rootScope, childValue);\n  }\n}\n\nfunction maybeFreeze(scope, value, deep) {\n  if (deep === void 0) {\n    deep = false;\n  }\n\n  // we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n    freeze(value, deep);\n  }\n}\n\n/**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */\n\nfunction createProxyProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var state = {\n    type_: isArray ? 1\n    /* ProxyArray */\n    : 0\n    /* ProxyObject */\n    ,\n    // Track which produce call this is associated with.\n    scope_: parent ? parent.scope_ : getCurrentScope(),\n    // True for both shallow and deep changes.\n    modified_: false,\n    // Used during finalization.\n    finalized_: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned_: {},\n    // The parent draft state.\n    parent_: parent,\n    // The base state.\n    base_: base,\n    // The base proxy.\n    draft_: null,\n    // The base copy with any updated values.\n    copy_: null,\n    // Called by the `produce` function.\n    revoke_: null,\n    isManual_: false\n  }; // the traps must target something, a bit like the 'real' base.\n  // but also, we need to be able to determine from the target what the relevant state is\n  // (to avoid creating traps per instance to capture the state in closure,\n  // and to avoid creating weird hidden properties as well)\n  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\n  var target = state;\n  var traps = objectTraps;\n\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  }\n\n  var _Proxy$revocable = Proxy.revocable(target, traps),\n      revoke = _Proxy$revocable.revoke,\n      proxy = _Proxy$revocable.proxy;\n\n  state.draft_ = proxy;\n  state.revoke_ = revoke;\n  return proxy;\n}\n/**\r\n * Object drafts\r\n */\n\nvar objectTraps = {\n  get: function get(state, prop) {\n    if (prop === DRAFT_STATE) return state;\n    var source = latest(state);\n\n    if (!has(source, prop)) {\n      // non-existing or non-own property...\n      return readPropFromProto(state, source, prop);\n    }\n\n    var value = source[prop];\n\n    if (state.finalized_ || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n    // Assigned values are never drafted. This catches any drafts we created, too.\n\n\n    if (value === peek(state.base_, prop)) {\n      prepareCopy(state);\n      return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);\n    }\n\n    return value;\n  },\n  has: function has(state, prop) {\n    return prop in latest(state);\n  },\n  ownKeys: function ownKeys(state) {\n    return Reflect.ownKeys(latest(state));\n  },\n  set: function set(state, prop\n  /* strictly not, but helps TS */\n  , value) {\n    var desc = getDescriptorFromProto(latest(state), prop);\n\n    if (desc === null || desc === void 0 ? void 0 : desc.set) {\n      // special case: if this write is captured by a setter, we have\n      // to trigger it with the correct context\n      desc.set.call(state.draft_, value);\n      return true;\n    }\n\n    if (!state.modified_) {\n      // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n      // from setting an existing property with value undefined to undefined (which is not a change)\n      var current = peek(latest(state), prop); // special case, if we assigning the original value to a draft, we can ignore the assignment\n\n      var currentState = current === null || current === void 0 ? void 0 : current[DRAFT_STATE];\n\n      if (currentState && currentState.base_ === value) {\n        state.copy_[prop] = value;\n        state.assigned_[prop] = false;\n        return true;\n      }\n\n      if (is(value, current) && (value !== undefined || has(state.base_, prop))) return true;\n      prepareCopy(state);\n      markChanged(state);\n    }\n\n    if (state.copy_[prop] === value && ( // special case: handle new props with value 'undefined'\n    value !== undefined || prop in state.copy_) || // special case: NaN\n    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true; // @ts-ignore\n\n    state.copy_[prop] = value;\n    state.assigned_[prop] = true;\n    return true;\n  },\n  deleteProperty: function deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek(state.base_, prop) !== undefined || prop in state.base_) {\n      state.assigned_[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else {\n      // if an originally not assigned property was deleted\n      delete state.assigned_[prop];\n    } // @ts-ignore\n\n\n    if (state.copy_) delete state.copy_[prop];\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n    var owner = latest(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (!desc) return desc;\n    return {\n      writable: true,\n      configurable: state.type_ !== 1\n      /* ProxyArray */\n      || prop !== \"length\",\n      enumerable: desc.enumerable,\n      value: owner[prop]\n    };\n  },\n  defineProperty: function defineProperty() {\n    die(11);\n  },\n  getPrototypeOf: function getPrototypeOf(state) {\n    return Object.getPrototypeOf(state.base_);\n  },\n  setPrototypeOf: function setPrototypeOf() {\n    die(12);\n  }\n};\n/**\r\n * Array drafts\r\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  // @ts-ignore\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if ( isNaN(parseInt(prop))) die(13); // @ts-ignore\n\n  return arrayTraps.set.call(this, state, prop, undefined);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if ( prop !== \"length\" && isNaN(parseInt(prop))) die(14);\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n}; // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var source = state ? latest(state) : draft;\n  return source[prop];\n}\n\nfunction readPropFromProto(state, source, prop) {\n  var _desc$get;\n\n  var desc = getDescriptorFromProto(source, prop);\n  return desc ? \"value\" in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the\n  // prototype, we should invoke it with the draft as context!\n  (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : undefined;\n}\n\nfunction getDescriptorFromProto(source, prop) {\n  // 'in' checks proto!\n  if (!(prop in source)) return undefined;\n  var proto = Object.getPrototypeOf(source);\n\n  while (proto) {\n    var desc = Object.getOwnPropertyDescriptor(proto, prop);\n    if (desc) return desc;\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return undefined;\n}\n\nfunction markChanged(state) {\n  if (!state.modified_) {\n    state.modified_ = true;\n\n    if (state.parent_) {\n      markChanged(state.parent_);\n    }\n  }\n}\nfunction prepareCopy(state) {\n  if (!state.copy_) {\n    state.copy_ = shallowCopy(state.base_);\n  }\n}\n\nvar Immer =\n/*#__PURE__*/\nfunction () {\n  function Immer(config) {\n    var _this = this;\n\n    this.useProxies_ = hasProxies;\n    this.autoFreeze_ = true;\n    /**\r\n     * The `produce` function takes a value and a \"recipe function\" (whose\r\n     * return value often depends on the base state). The recipe function is\r\n     * free to mutate its first argument however it wants. All mutations are\r\n     * only ever applied to a __copy__ of the base state.\r\n     *\r\n     * Pass only a function to create a \"curried producer\" which relieves you\r\n     * from passing the recipe function every time.\r\n     *\r\n     * Only plain objects and arrays are made mutable. All other objects are\r\n     * considered uncopyable.\r\n     *\r\n     * Note: This function is __bound__ to its `Immer` instance.\r\n     *\r\n     * @param {any} base - the initial state\r\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\r\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n     * @returns {any} a new state, or the initial state if nothing was modified\r\n     */\n\n    this.produce = function (base, recipe, patchListener) {\n      // curried invocation\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\n        var defaultBase = recipe;\n        recipe = base;\n        var self = _this;\n        return function curriedProduce(base) {\n          var _this2 = this;\n\n          if (base === void 0) {\n            base = defaultBase;\n          }\n\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          return self.produce(base, function (draft) {\n            var _recipe;\n\n            return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));\n          }); // prettier-ignore\n        };\n      }\n\n      if (typeof recipe !== \"function\") die(6);\n      if (patchListener !== undefined && typeof patchListener !== \"function\") die(7);\n      var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n      if (isDraftable(base)) {\n        var scope = enterScope(_this);\n        var proxy = createProxy(_this, base, undefined);\n        var hasError = true;\n\n        try {\n          result = recipe(proxy);\n          hasError = false;\n        } finally {\n          // finally instead of catch + rethrow better preserves original stack\n          if (hasError) revokeScope(scope);else leaveScope(scope);\n        }\n\n        if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n          return result.then(function (result) {\n            usePatchesInScope(scope, patchListener);\n            return processResult(result, scope);\n          }, function (error) {\n            revokeScope(scope);\n            throw error;\n          });\n        }\n\n        usePatchesInScope(scope, patchListener);\n        return processResult(result, scope);\n      } else if (!base || typeof base !== \"object\") {\n        result = recipe(base);\n        if (result === undefined) result = base;\n        if (result === NOTHING) result = undefined;\n        if (_this.autoFreeze_) freeze(result, true);\n\n        if (patchListener) {\n          var p = [];\n          var ip = [];\n          getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n          patchListener(p, ip);\n        }\n\n        return result;\n      } else die(21, base);\n    };\n\n    this.produceWithPatches = function (base, recipe) {\n      // curried invocation\n      if (typeof base === \"function\") {\n        return function (state) {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          return _this.produceWithPatches(state, function (draft) {\n            return base.apply(void 0, [draft].concat(args));\n          });\n        };\n      }\n\n      var patches, inversePatches;\n\n      var result = _this.produce(base, recipe, function (p, ip) {\n        patches = p;\n        inversePatches = ip;\n      });\n\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then(function (nextState) {\n          return [nextState, patches, inversePatches];\n        });\n      }\n\n      return [result, patches, inversePatches];\n    };\n\n    if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === \"boolean\") this.setUseProxies(config.useProxies);\n    if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === \"boolean\") this.setAutoFreeze(config.autoFreeze);\n  }\n\n  var _proto = Immer.prototype;\n\n  _proto.createDraft = function createDraft(base) {\n    if (!isDraftable(base)) die(8);\n    if (isDraft(base)) base = current(base);\n    var scope = enterScope(this);\n    var proxy = createProxy(this, base, undefined);\n    proxy[DRAFT_STATE].isManual_ = true;\n    leaveScope(scope);\n    return proxy;\n  };\n\n  _proto.finishDraft = function finishDraft(draft, patchListener) {\n    var state = draft && draft[DRAFT_STATE];\n\n    {\n      if (!state || !state.isManual_) die(9);\n      if (state.finalized_) die(10);\n    }\n\n    var scope = state.scope_;\n    usePatchesInScope(scope, patchListener);\n    return processResult(undefined, scope);\n  }\n  /**\r\n   * Pass true to automatically freeze all copies created by Immer.\r\n   *\r\n   * By default, auto-freezing is enabled.\r\n   */\n  ;\n\n  _proto.setAutoFreeze = function setAutoFreeze(value) {\n    this.autoFreeze_ = value;\n  }\n  /**\r\n   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n   * always faster than using ES5 proxies.\r\n   *\r\n   * By default, feature detection is used, so calling this is rarely necessary.\r\n   */\n  ;\n\n  _proto.setUseProxies = function setUseProxies(value) {\n    if (value && !hasProxies) {\n      die(20);\n    }\n\n    this.useProxies_ = value;\n  };\n\n  _proto.applyPatches = function applyPatches(base, patches) {\n    // If a patch replaces the entire state, take that replacement as base\n    // before applying patches\n    var i;\n\n    for (i = patches.length - 1; i >= 0; i--) {\n      var patch = patches[i];\n\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    } // If there was a patch that replaced the entire state, start from the\n    // patch after that.\n\n\n    if (i > -1) {\n      patches = patches.slice(i + 1);\n    }\n\n    var applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n\n    if (isDraft(base)) {\n      // N.B: never hits if some patch a replacement, patches are never drafts\n      return applyPatchesImpl(base, patches);\n    } // Otherwise, produce a copy of the base state.\n\n\n    return this.produce(base, function (draft) {\n      return applyPatchesImpl(draft, patches);\n    });\n  };\n\n  return Immer;\n}();\nfunction createProxy(immer, value, parent) {\n  // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n  var draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : immer.useProxies_ ? createProxyProxy(value, parent) : getPlugin(\"ES5\").createES5Proxy_(value, parent);\n  var scope = parent ? parent.scope_ : getCurrentScope();\n  scope.drafts_.push(draft);\n  return draft;\n}\n\nfunction current(value) {\n  if (!isDraft(value)) die(22, value);\n  return currentImpl(value);\n}\n\nfunction currentImpl(value) {\n  if (!isDraftable(value)) return value;\n  var state = value[DRAFT_STATE];\n  var copy;\n  var archType = getArchtype(value);\n\n  if (state) {\n    if (!state.modified_ && (state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state))) return state.base_; // Optimization: avoid generating new drafts during copying\n\n    state.finalized_ = true;\n    copy = copyHelper(value, archType);\n    state.finalized_ = false;\n  } else {\n    copy = copyHelper(value, archType);\n  }\n\n  each(copy, function (key, childValue) {\n    if (state && get(state.base_, key) === childValue) return; // no need to copy or search in something that didn't change\n\n    set(copy, key, currentImpl(childValue));\n  }); // In the future, we might consider freezing here, based on the current settings\n\n  return archType === 3\n  /* Set */\n  ? new Set(copy) : copy;\n}\n\nfunction copyHelper(value, archType) {\n  // creates a shallow copy, even if it is a map or set\n  switch (archType) {\n    case 2\n    /* Map */\n    :\n      return new Map(value);\n\n    case 3\n    /* Set */\n    :\n      // Set will be cloned as array temporarily, so that we can replace individual items\n      return Array.from(value);\n  }\n\n  return shallowCopy(value);\n}\n\nfunction enableES5() {\n  function willFinalizeES5_(scope, result, isReplaced) {\n    if (!isReplaced) {\n      if (scope.patches_) {\n        markChangesRecursively(scope.drafts_[0]);\n      } // This is faster when we don't care about which attributes changed.\n\n\n      markChangesSweep(scope.drafts_);\n    } // When a child draft is returned, look for changes.\n    else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {\n        markChangesSweep(scope.drafts_);\n      }\n  }\n\n  function createES5Draft(isArray, base) {\n    if (isArray) {\n      var draft = new Array(base.length);\n\n      for (var i = 0; i < base.length; i++) {\n        Object.defineProperty(draft, \"\" + i, proxyProperty(i, true));\n      }\n\n      return draft;\n    } else {\n      var _descriptors = getOwnPropertyDescriptors(base);\n\n      delete _descriptors[DRAFT_STATE];\n      var keys = ownKeys(_descriptors);\n\n      for (var _i = 0; _i < keys.length; _i++) {\n        var key = keys[_i];\n        _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);\n      }\n\n      return Object.create(Object.getPrototypeOf(base), _descriptors);\n    }\n  }\n\n  function createES5Proxy_(base, parent) {\n    var isArray = Array.isArray(base);\n    var draft = createES5Draft(isArray, base);\n    var state = {\n      type_: isArray ? 5\n      /* ES5Array */\n      : 4\n      /* ES5Object */\n      ,\n      scope_: parent ? parent.scope_ : getCurrentScope(),\n      modified_: false,\n      finalized_: false,\n      assigned_: {},\n      parent_: parent,\n      // base is the object we are drafting\n      base_: base,\n      // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n      draft_: draft,\n      copy_: null,\n      revoked_: false,\n      isManual_: false\n    };\n    Object.defineProperty(draft, DRAFT_STATE, {\n      value: state,\n      // enumerable: false <- the default\n      writable: true\n    });\n    return draft;\n  } // property descriptors are recycled to make sure we don't create a get and set closure per property,\n  // but share them all instead\n\n\n  var descriptors = {};\n\n  function proxyProperty(prop, enumerable) {\n    var desc = descriptors[prop];\n\n    if (desc) {\n      desc.enumerable = enumerable;\n    } else {\n      descriptors[prop] = desc = {\n        configurable: true,\n        enumerable: enumerable,\n        get: function get() {\n          var state = this[DRAFT_STATE];\n          assertUnrevoked(state); // @ts-ignore\n\n          return objectTraps.get(state, prop);\n        },\n        set: function set(value) {\n          var state = this[DRAFT_STATE];\n          assertUnrevoked(state); // @ts-ignore\n\n          objectTraps.set(state, prop, value);\n        }\n      };\n    }\n\n    return desc;\n  } // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\n  function markChangesSweep(drafts) {\n    // The natural order of drafts in the `scope` array is based on when they\n    // were accessed. By processing drafts in reverse natural order, we have a\n    // better chance of processing leaf nodes first. When a leaf node is known to\n    // have changed, we can avoid any traversal of its ancestor nodes.\n    for (var i = drafts.length - 1; i >= 0; i--) {\n      var state = drafts[i][DRAFT_STATE];\n\n      if (!state.modified_) {\n        switch (state.type_) {\n          case 5\n          /* ES5Array */\n          :\n            if (hasArrayChanges(state)) markChanged(state);\n            break;\n\n          case 4\n          /* ES5Object */\n          :\n            if (hasObjectChanges(state)) markChanged(state);\n            break;\n        }\n      }\n    }\n  }\n\n  function markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return;\n    var state = object[DRAFT_STATE];\n    if (!state) return;\n    var base_ = state.base_,\n        draft_ = state.draft_,\n        assigned_ = state.assigned_,\n        type_ = state.type_;\n\n    if (type_ === 4\n    /* ES5Object */\n    ) {\n        // Look for added keys.\n        // probably there is a faster way to detect changes, as sweep + recurse seems to do some\n        // unnecessary work.\n        // also: probably we can store the information we detect here, to speed up tree finalization!\n        each(draft_, function (key) {\n          if (key === DRAFT_STATE) return; // The `undefined` check is a fast path for pre-existing keys.\n\n          if (base_[key] === undefined && !has(base_, key)) {\n            assigned_[key] = true;\n            markChanged(state);\n          } else if (!assigned_[key]) {\n            // Only untouched properties trigger recursion.\n            markChangesRecursively(draft_[key]);\n          }\n        }); // Look for removed keys.\n\n        each(base_, function (key) {\n          // The `undefined` check is a fast path for pre-existing keys.\n          if (draft_[key] === undefined && !has(draft_, key)) {\n            assigned_[key] = false;\n            markChanged(state);\n          }\n        });\n      } else if (type_ === 5\n    /* ES5Array */\n    ) {\n        if (hasArrayChanges(state)) {\n          markChanged(state);\n          assigned_.length = true;\n        }\n\n        if (draft_.length < base_.length) {\n          for (var i = draft_.length; i < base_.length; i++) {\n            assigned_[i] = false;\n          }\n        } else {\n          for (var _i2 = base_.length; _i2 < draft_.length; _i2++) {\n            assigned_[_i2] = true;\n          }\n        } // Minimum count is enough, the other parts has been processed.\n\n\n        var min = Math.min(draft_.length, base_.length);\n\n        for (var _i3 = 0; _i3 < min; _i3++) {\n          // Only untouched indices trigger recursion.\n          if (!draft_.hasOwnProperty(_i3)) {\n            assigned_[_i3] = true;\n          }\n\n          if (assigned_[_i3] === undefined) markChangesRecursively(draft_[_i3]);\n        }\n      }\n  }\n\n  function hasObjectChanges(state) {\n    var base_ = state.base_,\n        draft_ = state.draft_; // Search for added keys and changed keys. Start at the back, because\n    // non-numeric keys are ordered by time of definition on the object.\n\n    var keys = ownKeys(draft_);\n\n    for (var i = keys.length - 1; i >= 0; i--) {\n      var key = keys[i];\n      if (key === DRAFT_STATE) continue;\n      var baseValue = base_[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n      if (baseValue === undefined && !has(base_, key)) {\n        return true;\n      } // Once a base key is deleted, future changes go undetected, because its\n      // descriptor is erased. This branch detects any missed changes.\n      else {\n          var value = draft_[key];\n\n          var _state = value && value[DRAFT_STATE];\n\n          if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {\n            return true;\n          }\n        }\n    } // At this point, no keys were added or changed.\n    // Compare key count to determine if keys were deleted.\n\n\n    var baseIsDraft = !!base_[DRAFT_STATE];\n    return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE\n  }\n\n  function hasArrayChanges(state) {\n    var draft_ = state.draft_;\n    if (draft_.length !== state.base_.length) return true; // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    // last descriptor can be not a trap, if the array was extended\n\n    var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n    if (descriptor && !descriptor.get) return true; // if we miss a property, it has been deleted, so array probobaly changed\n\n    for (var i = 0; i < draft_.length; i++) {\n      if (!draft_.hasOwnProperty(i)) return true;\n    } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n\n    return false;\n  }\n\n  function hasChanges_(state) {\n    return state.type_ === 4\n    /* ES5Object */\n    ? hasObjectChanges(state) : hasArrayChanges(state);\n  }\n\n  function assertUnrevoked(state\n  /*ES5State | MapState | SetState*/\n  ) {\n    if (state.revoked_) die(3, JSON.stringify(latest(state)));\n  }\n\n  loadPlugin(\"ES5\", {\n    createES5Proxy_: createES5Proxy_,\n    willFinalizeES5_: willFinalizeES5_,\n    hasChanges_: hasChanges_\n  });\n}\n\nfunction enablePatches() {\n  var REPLACE = \"replace\";\n  var ADD = \"add\";\n  var REMOVE = \"remove\";\n\n  function generatePatches_(state, basePath, patches, inversePatches) {\n    switch (state.type_) {\n      case 0\n      /* ProxyObject */\n      :\n      case 4\n      /* ES5Object */\n      :\n      case 2\n      /* Map */\n      :\n        return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\n\n      case 5\n      /* ES5Array */\n      :\n      case 1\n      /* ProxyArray */\n      :\n        return generateArrayPatches(state, basePath, patches, inversePatches);\n\n      case 3\n      /* Set */\n      :\n        return generateSetPatches(state, basePath, patches, inversePatches);\n    }\n  }\n\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\n    var base_ = state.base_,\n        assigned_ = state.assigned_;\n    var copy_ = state.copy_; // Reduce complexity by ensuring `base` is never longer.\n\n    if (copy_.length < base_.length) {\n      var _ref = [copy_, base_];\n      base_ = _ref[0];\n      copy_ = _ref[1];\n      var _ref2 = [inversePatches, patches];\n      patches = _ref2[0];\n      inversePatches = _ref2[1];\n    } // Process replaced indices.\n\n\n    for (var i = 0; i < base_.length; i++) {\n      if (assigned_[i] && copy_[i] !== base_[i]) {\n        var path = basePath.concat([i]);\n        patches.push({\n          op: REPLACE,\n          path: path,\n          // Need to maybe clone it, as it can in fact be the original value\n          // due to the base/copy inversion at the start of this function\n          value: clonePatchValueIfNeeded(copy_[i])\n        });\n        inversePatches.push({\n          op: REPLACE,\n          path: path,\n          value: clonePatchValueIfNeeded(base_[i])\n        });\n      }\n    } // Process added indices.\n\n\n    for (var _i = base_.length; _i < copy_.length; _i++) {\n      var _path = basePath.concat([_i]);\n\n      patches.push({\n        op: ADD,\n        path: _path,\n        // Need to maybe clone it, as it can in fact be the original value\n        // due to the base/copy inversion at the start of this function\n        value: clonePatchValueIfNeeded(copy_[_i])\n      });\n    }\n\n    if (base_.length < copy_.length) {\n      inversePatches.push({\n        op: REPLACE,\n        path: basePath.concat([\"length\"]),\n        value: base_.length\n      });\n    }\n  } // This is used for both Map objects and normal objects.\n\n\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n    var base_ = state.base_,\n        copy_ = state.copy_;\n    each(state.assigned_, function (key, assignedValue) {\n      var origValue = get(base_, key);\n      var value = get(copy_, key);\n      var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n      if (origValue === value && op === REPLACE) return;\n      var path = basePath.concat(key);\n      patches.push(op === REMOVE ? {\n        op: op,\n        path: path\n      } : {\n        op: op,\n        path: path,\n        value: value\n      });\n      inversePatches.push(op === ADD ? {\n        op: REMOVE,\n        path: path\n      } : op === REMOVE ? {\n        op: ADD,\n        path: path,\n        value: clonePatchValueIfNeeded(origValue)\n      } : {\n        op: REPLACE,\n        path: path,\n        value: clonePatchValueIfNeeded(origValue)\n      });\n    });\n  }\n\n  function generateSetPatches(state, basePath, patches, inversePatches) {\n    var base_ = state.base_,\n        copy_ = state.copy_;\n    var i = 0;\n    base_.forEach(function (value) {\n      if (!copy_.has(value)) {\n        var path = basePath.concat([i]);\n        patches.push({\n          op: REMOVE,\n          path: path,\n          value: value\n        });\n        inversePatches.unshift({\n          op: ADD,\n          path: path,\n          value: value\n        });\n      }\n\n      i++;\n    });\n    i = 0;\n    copy_.forEach(function (value) {\n      if (!base_.has(value)) {\n        var path = basePath.concat([i]);\n        patches.push({\n          op: ADD,\n          path: path,\n          value: value\n        });\n        inversePatches.unshift({\n          op: REMOVE,\n          path: path,\n          value: value\n        });\n      }\n\n      i++;\n    });\n  }\n\n  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n    patches.push({\n      op: REPLACE,\n      path: [],\n      value: replacement === NOTHING ? undefined : replacement\n    });\n    inversePatches.push({\n      op: REPLACE,\n      path: [],\n      value: baseValue\n    });\n  }\n\n  function applyPatches_(draft, patches) {\n    patches.forEach(function (patch) {\n      var path = patch.path,\n          op = patch.op;\n      var base = draft;\n\n      for (var i = 0; i < path.length - 1; i++) {\n        var parentType = getArchtype(base);\n        var p = path[i];\n\n        if (typeof p !== \"string\" && typeof p !== \"number\") {\n          p = \"\" + p;\n        } // See #738, avoid prototype pollution\n\n\n        if ((parentType === 0\n        /* Object */\n        || parentType === 1\n        /* Array */\n        ) && (p === \"__proto__\" || p === \"constructor\")) die(24);\n        if (typeof base === \"function\" && p === \"prototype\") die(24);\n        base = get(base, p);\n        if (typeof base !== \"object\") die(15, path.join(\"/\"));\n      }\n\n      var type = getArchtype(base);\n      var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n      var key = path[path.length - 1];\n\n      switch (op) {\n        case REPLACE:\n          switch (type) {\n            case 2\n            /* Map */\n            :\n              return base.set(key, value);\n\n            /* istanbul ignore next */\n\n            case 3\n            /* Set */\n            :\n              die(16);\n\n            default:\n              // if value is an object, then it's assigned by reference\n              // in the following add or remove ops, the value field inside the patch will also be modifyed\n              // so we use value from the cloned patch\n              // @ts-ignore\n              return base[key] = value;\n          }\n\n        case ADD:\n          switch (type) {\n            case 1\n            /* Array */\n            :\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n\n            case 2\n            /* Map */\n            :\n              return base.set(key, value);\n\n            case 3\n            /* Set */\n            :\n              return base.add(value);\n\n            default:\n              return base[key] = value;\n          }\n\n        case REMOVE:\n          switch (type) {\n            case 1\n            /* Array */\n            :\n              return base.splice(key, 1);\n\n            case 2\n            /* Map */\n            :\n              return base.delete(key);\n\n            case 3\n            /* Set */\n            :\n              return base.delete(patch.value);\n\n            default:\n              return delete base[key];\n          }\n\n        default:\n          die(17, op);\n      }\n    });\n    return draft;\n  }\n\n  function deepClonePatchValue(obj) {\n    if (!isDraftable(obj)) return obj;\n    if (Array.isArray(obj)) return obj.map(deepClonePatchValue);\n    if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function (_ref3) {\n      var k = _ref3[0],\n          v = _ref3[1];\n      return [k, deepClonePatchValue(v)];\n    }));\n    if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\n    var cloned = Object.create(Object.getPrototypeOf(obj));\n\n    for (var key in obj) {\n      cloned[key] = deepClonePatchValue(obj[key]);\n    }\n\n    if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\n    return cloned;\n  }\n\n  function clonePatchValueIfNeeded(obj) {\n    if (isDraft(obj)) {\n      return deepClonePatchValue(obj);\n    } else return obj;\n  }\n\n  loadPlugin(\"Patches\", {\n    applyPatches_: applyPatches_,\n    generatePatches_: generatePatches_,\n    generateReplacementPatches_: generateReplacementPatches_\n  });\n}\n\n// types only!\nfunction enableMapSet() {\n  /* istanbul ignore next */\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  }; // Ugly hack to resolve #502 and inherit built in Map / Set\n\n\n  function __extends(d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = ( // @ts-ignore\n    __.prototype = b.prototype, new __());\n  }\n\n  var DraftMap = function (_super) {\n    __extends(DraftMap, _super); // Create class manually, cause #502\n\n\n    function DraftMap(target, parent) {\n      this[DRAFT_STATE] = {\n        type_: 2\n        /* Map */\n        ,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: undefined,\n        assigned_: undefined,\n        base_: target,\n        draft_: this,\n        isManual_: false,\n        revoked_: false\n      };\n      return this;\n    }\n\n    var p = DraftMap.prototype;\n    Object.defineProperty(p, \"size\", {\n      get: function get() {\n        return latest(this[DRAFT_STATE]).size;\n      } // enumerable: false,\n      // configurable: true\n\n    });\n\n    p.has = function (key) {\n      return latest(this[DRAFT_STATE]).has(key);\n    };\n\n    p.set = function (key, value) {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (!latest(state).has(key) || latest(state).get(key) !== value) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_.set(key, true);\n        state.copy_.set(key, value);\n        state.assigned_.set(key, true);\n      }\n\n      return this;\n    };\n\n    p.delete = function (key) {\n      if (!this.has(key)) {\n        return false;\n      }\n\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareMapCopy(state);\n      markChanged(state);\n\n      if (state.base_.has(key)) {\n        state.assigned_.set(key, false);\n      } else {\n        state.assigned_.delete(key);\n      }\n\n      state.copy_.delete(key);\n      return true;\n    };\n\n    p.clear = function () {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (latest(state).size) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_ = new Map();\n        each(state.base_, function (key) {\n          state.assigned_.set(key, false);\n        });\n        state.copy_.clear();\n      }\n    };\n\n    p.forEach = function (cb, thisArg) {\n      var _this = this;\n\n      var state = this[DRAFT_STATE];\n      latest(state).forEach(function (_value, key, _map) {\n        cb.call(thisArg, _this.get(key), key, _this);\n      });\n    };\n\n    p.get = function (key) {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      var value = latest(state).get(key);\n\n      if (state.finalized_ || !isDraftable(value)) {\n        return value;\n      }\n\n      if (value !== state.base_.get(key)) {\n        return value; // either already drafted or reassigned\n      } // despite what it looks, this creates a draft only once, see above condition\n\n\n      var draft = createProxy(state.scope_.immer_, value, state);\n      prepareMapCopy(state);\n      state.copy_.set(key, draft);\n      return draft;\n    };\n\n    p.keys = function () {\n      return latest(this[DRAFT_STATE]).keys();\n    };\n\n    p.values = function () {\n      var _this2 = this,\n          _ref;\n\n      var iterator = this.keys();\n      return _ref = {}, _ref[iteratorSymbol] = function () {\n        return _this2.values();\n      }, _ref.next = function next() {\n        var r = iterator.next();\n        /* istanbul ignore next */\n\n        if (r.done) return r;\n\n        var value = _this2.get(r.value);\n\n        return {\n          done: false,\n          value: value\n        };\n      }, _ref;\n    };\n\n    p.entries = function () {\n      var _this3 = this,\n          _ref2;\n\n      var iterator = this.keys();\n      return _ref2 = {}, _ref2[iteratorSymbol] = function () {\n        return _this3.entries();\n      }, _ref2.next = function next() {\n        var r = iterator.next();\n        /* istanbul ignore next */\n\n        if (r.done) return r;\n\n        var value = _this3.get(r.value);\n\n        return {\n          done: false,\n          value: [r.value, value]\n        };\n      }, _ref2;\n    };\n\n    p[iteratorSymbol] = function () {\n      return this.entries();\n    };\n\n    return DraftMap;\n  }(Map);\n\n  function proxyMap_(target, parent) {\n    // @ts-ignore\n    return new DraftMap(target, parent);\n  }\n\n  function prepareMapCopy(state) {\n    if (!state.copy_) {\n      state.assigned_ = new Map();\n      state.copy_ = new Map(state.base_);\n    }\n  }\n\n  var DraftSet = function (_super) {\n    __extends(DraftSet, _super); // Create class manually, cause #502\n\n\n    function DraftSet(target, parent) {\n      this[DRAFT_STATE] = {\n        type_: 3\n        /* Set */\n        ,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: undefined,\n        base_: target,\n        draft_: this,\n        drafts_: new Map(),\n        revoked_: false,\n        isManual_: false\n      };\n      return this;\n    }\n\n    var p = DraftSet.prototype;\n    Object.defineProperty(p, \"size\", {\n      get: function get() {\n        return latest(this[DRAFT_STATE]).size;\n      } // enumerable: true,\n\n    });\n\n    p.has = function (value) {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value\n\n      if (!state.copy_) {\n        return state.base_.has(value);\n      }\n\n      if (state.copy_.has(value)) return true;\n      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\n      return false;\n    };\n\n    p.add = function (value) {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (!this.has(value)) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.add(value);\n      }\n\n      return this;\n    };\n\n    p.delete = function (value) {\n      if (!this.has(value)) {\n        return false;\n      }\n\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      markChanged(state);\n      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) :\n      /* istanbul ignore next */\n      false);\n    };\n\n    p.clear = function () {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (latest(state).size) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.clear();\n      }\n    };\n\n    p.values = function () {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.values();\n    };\n\n    p.entries = function entries() {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.entries();\n    };\n\n    p.keys = function () {\n      return this.values();\n    };\n\n    p[iteratorSymbol] = function () {\n      return this.values();\n    };\n\n    p.forEach = function forEach(cb, thisArg) {\n      var iterator = this.values();\n      var result = iterator.next();\n\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, this);\n        result = iterator.next();\n      }\n    };\n\n    return DraftSet;\n  }(Set);\n\n  function proxySet_(target, parent) {\n    // @ts-ignore\n    return new DraftSet(target, parent);\n  }\n\n  function prepareSetCopy(state) {\n    if (!state.copy_) {\n      // create drafts for all entries to preserve insertion order\n      state.copy_ = new Set();\n      state.base_.forEach(function (value) {\n        if (isDraftable(value)) {\n          var draft = createProxy(state.scope_.immer_, value, state);\n          state.drafts_.set(value, draft);\n          state.copy_.add(draft);\n        } else {\n          state.copy_.add(value);\n        }\n      });\n    }\n  }\n\n  function assertUnrevoked(state\n  /*ES5State | MapState | SetState*/\n  ) {\n    if (state.revoked_) die(3, JSON.stringify(latest(state)));\n  }\n\n  loadPlugin(\"MapSet\", {\n    proxyMap_: proxyMap_,\n    proxySet_: proxySet_\n  });\n}\n\nfunction enableAllPlugins() {\n  enableES5();\n  enableMapSet();\n  enablePatches();\n}\n\nvar immer =\n/*#__PURE__*/\nnew Immer();\n/**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */\n\nvar produce = immer.produce;\n/**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */\n\nvar produceWithPatches =\n/*#__PURE__*/\nimmer.produceWithPatches.bind(immer);\n/**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * Always freeze by default, even in production mode\r\n */\n\nvar setAutoFreeze =\n/*#__PURE__*/\nimmer.setAutoFreeze.bind(immer);\n/**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */\n\nvar setUseProxies =\n/*#__PURE__*/\nimmer.setUseProxies.bind(immer);\n/**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */\n\nvar applyPatches =\n/*#__PURE__*/\nimmer.applyPatches.bind(immer);\n/**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */\n\nvar createDraft =\n/*#__PURE__*/\nimmer.createDraft.bind(immer);\n/**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */\n\nvar finishDraft =\n/*#__PURE__*/\nimmer.finishDraft.bind(immer);\n/**\r\n * This function is actually a no-op, but can be used to cast an immutable type\r\n * to an draft type and make TypeScript happy\r\n *\r\n * @param value\r\n */\n\nfunction castDraft(value) {\n  return value;\n}\n/**\r\n * This function is actually a no-op, but can be used to cast a mutable type\r\n * to an immutable type and make TypeScript happy\r\n * @param value\r\n */\n\nfunction castImmutable(value) {\n  return value;\n}\n\nexports.Immer = Immer;\nexports.applyPatches = applyPatches;\nexports.castDraft = castDraft;\nexports.castImmutable = castImmutable;\nexports.createDraft = createDraft;\nexports.current = current;\nexports[\"default\"] = produce;\nexports.enableAllPlugins = enableAllPlugins;\nexports.enableES5 = enableES5;\nexports.enableMapSet = enableMapSet;\nexports.enablePatches = enablePatches;\nexports.finishDraft = finishDraft;\nexports.freeze = freeze;\nexports.immerable = DRAFTABLE;\nexports.isDraft = isDraft;\nexports.isDraftable = isDraftable;\nexports.nothing = NOTHING;\nexports.original = original;\nexports.produce = produce;\nexports.produceWithPatches = produceWithPatches;\nexports.setAutoFreeze = setAutoFreeze;\nexports.setUseProxies = setUseProxies;\n//# sourceMappingURL=immer.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5janMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixhQUFhO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7OztBQUdKLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUVBQXlFOztBQUV6RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsS0FBSztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpR0FBaUcsYUFBYTtBQUM5RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLGVBQWU7QUFDcEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsUUFBUTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJHQUEyRzs7QUFFM0c7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0Msa0JBQWtCO0FBQ3hEO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsdUNBQXVDLHFCQUFxQjtBQUM1RDtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7O0FBRUEsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQSwwRUFBMEU7QUFDMUU7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRkFBaUY7O0FBRWpGLG9EQUFvRDs7QUFFcEQsb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07OztBQUdOLGdDQUFnQyxtQkFBbUI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7OztBQUdqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEIsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7OztBQUdqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixhQUFhLEtBQUs7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYixvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsZUFBZTtBQUNmLGtCQUFlO0FBQ2Ysd0JBQXdCO0FBQ3hCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixtQkFBbUI7QUFDbkIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVuLXJlc3VtZS8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLmNqcy5kZXZlbG9wbWVudC5qcz81MTZmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIF9yZWY7XG5cbi8vIFNob3VsZCBiZSBubyBpbXBvcnRzIGhlcmUhXG4vLyBTb21lIHRoaW5ncyB0aGF0IHNob3VsZCBiZSBldmFsdWF0ZWQgYmVmb3JlIGFsbCBlbHNlLi4uXG4vLyBXZSBvbmx5IHdhbnQgdG8ga25vdyBpZiBub24tcG9seWZpbGxlZCBzeW1ib2xzIGFyZSBhdmFpbGFibGVcbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZlxuLyojX19QVVJFX18qL1xuU3ltYm9sKFwieFwiKSA9PT0gXCJzeW1ib2xcIjtcbnZhciBoYXNNYXAgPSB0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIGhhc1NldCA9IHR5cGVvZiBTZXQgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgaGFzUHJveGllcyA9IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgUHJveHkucmV2b2NhYmxlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiO1xuLyoqXHJcbiAqIFRoZSBzZW50aW5lbCB2YWx1ZSByZXR1cm5lZCBieSBwcm9kdWNlcnMgdG8gcmVwbGFjZSB0aGUgZHJhZnQgd2l0aCB1bmRlZmluZWQuXHJcbiAqL1xuXG52YXIgTk9USElORyA9IGhhc1N5bWJvbCA/XG4vKiNfX1BVUkVfXyovXG5TeW1ib2wuZm9yKFwiaW1tZXItbm90aGluZ1wiKSA6IChfcmVmID0ge30sIF9yZWZbXCJpbW1lci1ub3RoaW5nXCJdID0gdHJ1ZSwgX3JlZik7XG4vKipcclxuICogVG8gbGV0IEltbWVyIHRyZWF0IHlvdXIgY2xhc3MgaW5zdGFuY2VzIGFzIHBsYWluIGltbXV0YWJsZSBvYmplY3RzXHJcbiAqIChhbGJlaXQgd2l0aCBhIGN1c3RvbSBwcm90b3R5cGUpLCB5b3UgbXVzdCBkZWZpbmUgZWl0aGVyIGFuIGluc3RhbmNlIHByb3BlcnR5XHJcbiAqIG9yIGEgc3RhdGljIHByb3BlcnR5IG9uIGVhY2ggb2YgeW91ciBjdXN0b20gY2xhc3Nlcy5cclxuICpcclxuICogT3RoZXJ3aXNlLCB5b3VyIGNsYXNzIGluc3RhbmNlIHdpbGwgbmV2ZXIgYmUgZHJhZnRlZCwgd2hpY2ggbWVhbnMgaXQgd29uJ3QgYmVcclxuICogc2FmZSB0byBtdXRhdGUgaW4gYSBwcm9kdWNlIGNhbGxiYWNrLlxyXG4gKi9cblxudmFyIERSQUZUQUJMRSA9IGhhc1N5bWJvbCA/XG4vKiNfX1BVUkVfXyovXG5TeW1ib2wuZm9yKFwiaW1tZXItZHJhZnRhYmxlXCIpIDogXCJfXyRpbW1lcl9kcmFmdGFibGVcIjtcbnZhciBEUkFGVF9TVEFURSA9IGhhc1N5bWJvbCA/XG4vKiNfX1BVUkVfXyovXG5TeW1ib2wuZm9yKFwiaW1tZXItc3RhdGVcIikgOiBcIl9fJGltbWVyX3N0YXRlXCI7IC8vIEV2ZW4gYSBwb2x5ZmlsbGVkIFN5bWJvbCBtaWdodCBwcm92aWRlIFN5bWJvbC5pdGVyYXRvclxuXG52YXIgaXRlcmF0b3JTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuXG52YXIgZXJyb3JzID0ge1xuICAwOiBcIklsbGVnYWwgc3RhdGVcIixcbiAgMTogXCJJbW1lciBkcmFmdHMgY2Fubm90IGhhdmUgY29tcHV0ZWQgcHJvcGVydGllc1wiLFxuICAyOiBcIlRoaXMgb2JqZWN0IGhhcyBiZWVuIGZyb3plbiBhbmQgc2hvdWxkIG5vdCBiZSBtdXRhdGVkXCIsXG4gIDM6IGZ1bmN0aW9uIF8oZGF0YSkge1xuICAgIHJldHVybiBcIkNhbm5vdCB1c2UgYSBwcm94eSB0aGF0IGhhcyBiZWVuIHJldm9rZWQuIERpZCB5b3UgcGFzcyBhbiBvYmplY3QgZnJvbSBpbnNpZGUgYW4gaW1tZXIgZnVuY3Rpb24gdG8gYW4gYXN5bmMgcHJvY2Vzcz8gXCIgKyBkYXRhO1xuICB9LFxuICA0OiBcIkFuIGltbWVyIHByb2R1Y2VyIHJldHVybmVkIGEgbmV3IHZhbHVlICphbmQqIG1vZGlmaWVkIGl0cyBkcmFmdC4gRWl0aGVyIHJldHVybiBhIG5ldyB2YWx1ZSAqb3IqIG1vZGlmeSB0aGUgZHJhZnQuXCIsXG4gIDU6IFwiSW1tZXIgZm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VzXCIsXG4gIDY6IFwiVGhlIGZpcnN0IG9yIHNlY29uZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsXG4gIDc6IFwiVGhlIHRoaXJkIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgdW5kZWZpbmVkXCIsXG4gIDg6IFwiRmlyc3QgYXJndW1lbnQgdG8gYGNyZWF0ZURyYWZ0YCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LCBhbiBhcnJheSwgb3IgYW4gaW1tZXJhYmxlIG9iamVjdFwiLFxuICA5OiBcIkZpcnN0IGFyZ3VtZW50IHRvIGBmaW5pc2hEcmFmdGAgbXVzdCBiZSBhIGRyYWZ0IHJldHVybmVkIGJ5IGBjcmVhdGVEcmFmdGBcIixcbiAgMTA6IFwiVGhlIGdpdmVuIGRyYWZ0IGlzIGFscmVhZHkgZmluYWxpemVkXCIsXG4gIDExOiBcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsXG4gIDEyOiBcIk9iamVjdC5zZXRQcm90b3R5cGVPZigpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsXG4gIDEzOiBcIkltbWVyIG9ubHkgc3VwcG9ydHMgZGVsZXRpbmcgYXJyYXkgaW5kaWNlc1wiLFxuICAxNDogXCJJbW1lciBvbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5XCIsXG4gIDE1OiBmdW5jdGlvbiBfKHBhdGgpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIiArIHBhdGg7XG4gIH0sXG4gIDE2OiAnU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsXG4gIDE3OiBmdW5jdGlvbiBfKG9wKSB7XG4gICAgcmV0dXJuIFwiVW5zdXBwb3J0ZWQgcGF0Y2ggb3BlcmF0aW9uOiBcIiArIG9wO1xuICB9LFxuICAxODogZnVuY3Rpb24gXyhwbHVnaW4pIHtcbiAgICByZXR1cm4gXCJUaGUgcGx1Z2luIGZvciAnXCIgKyBwbHVnaW4gKyBcIicgaGFzIG5vdCBiZWVuIGxvYWRlZCBpbnRvIEltbWVyLiBUbyBlbmFibGUgdGhlIHBsdWdpbiwgaW1wb3J0IGFuZCBjYWxsIGBlbmFibGVcIiArIHBsdWdpbiArIFwiKClgIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXIgYXBwbGljYXRpb24uXCI7XG4gIH0sXG4gIDIwOiBcIkNhbm5vdCB1c2UgcHJveGllcyBpZiBQcm94eSwgUHJveHkucmV2b2NhYmxlIG9yIFJlZmxlY3QgYXJlIG5vdCBhdmFpbGFibGVcIixcbiAgMjE6IGZ1bmN0aW9uIF8odGhpbmcpIHtcbiAgICByZXR1cm4gXCJwcm9kdWNlIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGluZ3MgdGhhdCBhcmUgZHJhZnRhYmxlOiBwbGFpbiBvYmplY3RzLCBhcnJheXMsIE1hcCwgU2V0IG9yIGNsYXNzZXMgdGhhdCBhcmUgbWFya2VkIHdpdGggJ1tpbW1lcmFibGVdOiB0cnVlJy4gR290ICdcIiArIHRoaW5nICsgXCInXCI7XG4gIH0sXG4gIDIyOiBmdW5jdGlvbiBfKHRoaW5nKSB7XG4gICAgcmV0dXJuIFwiJ2N1cnJlbnQnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiBcIiArIHRoaW5nO1xuICB9LFxuICAyMzogZnVuY3Rpb24gXyh0aGluZykge1xuICAgIHJldHVybiBcIidvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6IFwiICsgdGhpbmc7XG4gIH0sXG4gIDI0OiBcIlBhdGNoaW5nIHJlc2VydmVkIGF0dHJpYnV0ZXMgbGlrZSBfX3Byb3RvX18sIHByb3RvdHlwZSBhbmQgY29uc3RydWN0b3IgaXMgbm90IGFsbG93ZWRcIlxufTtcbmZ1bmN0aW9uIGRpZShlcnJvcikge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB7XG4gICAgdmFyIGUgPSBlcnJvcnNbZXJyb3JdO1xuICAgIHZhciBtc2cgPSAhZSA/IFwidW5rbm93biBlcnJvciBucjogXCIgKyBlcnJvciA6IHR5cGVvZiBlID09PSBcImZ1bmN0aW9uXCIgPyBlLmFwcGx5KG51bGwsIGFyZ3MpIDogZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbSW1tZXJdIFwiICsgbXNnKTtcbiAgfVxufVxuXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBJbW1lciBkcmFmdCAqL1xuXG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGlzRHJhZnQodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgISF2YWx1ZVtEUkFGVF9TVEFURV07XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgZHJhZnRlZCBieSBJbW1lciAqL1xuXG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGlzRHJhZnRhYmxlKHZhbHVlKSB7XG4gIHZhciBfdmFsdWUkY29uc3RydWN0b3I7XG5cbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgISF2YWx1ZVtEUkFGVEFCTEVdIHx8ICEhKChfdmFsdWUkY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX3ZhbHVlJGNvbnN0cnVjdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmFsdWUkY29uc3RydWN0b3JbRFJBRlRBQkxFXSkgfHwgaXNNYXAodmFsdWUpIHx8IGlzU2V0KHZhbHVlKTtcbn1cbnZhciBvYmplY3RDdG9yU3RyaW5nID1cbi8qI19fUFVSRV9fKi9cbk9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IudG9TdHJpbmcoKTtcbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuXG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIEN0b3IgPSBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgXCJjb25zdHJ1Y3RvclwiKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgaWYgKEN0b3IgPT09IE9iamVjdCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSBcImZ1bmN0aW9uXCIgJiYgRnVuY3Rpb24udG9TdHJpbmcuY2FsbChDdG9yKSA9PT0gb2JqZWN0Q3RvclN0cmluZztcbn1cbmZ1bmN0aW9uIG9yaWdpbmFsKHZhbHVlKSB7XG4gIGlmICghaXNEcmFmdCh2YWx1ZSkpIGRpZSgyMywgdmFsdWUpO1xuICByZXR1cm4gdmFsdWVbRFJBRlRfU1RBVEVdLmJhc2VfO1xufVxuLyojX19QVVJFX18qL1xuXG52YXIgb3duS2V5cyA9IHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Qub3duS2V5cyA/IFJlZmxlY3Qub3duS2V5cyA6IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSBcInVuZGVmaW5lZFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopKTtcbn0gOlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRhcmdldCkge1xuICAvLyBQb2x5ZmlsbCBuZWVkZWQgZm9yIEhlcm1lcyBhbmQgSUUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svaGVybWVzL2lzc3Vlcy8yNzRcbiAgdmFyIHJlcyA9IHt9O1xuICBvd25LZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmVzW2tleV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgfSk7XG4gIHJldHVybiByZXM7XG59O1xuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXIsIGVudW1lcmFibGVPbmx5KSB7XG4gIGlmIChlbnVtZXJhYmxlT25seSA9PT0gdm9pZCAwKSB7XG4gICAgZW51bWVyYWJsZU9ubHkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChnZXRBcmNodHlwZShvYmopID09PSAwXG4gIC8qIE9iamVjdCAqL1xuICApIHtcbiAgICAgIChlbnVtZXJhYmxlT25seSA/IE9iamVjdC5rZXlzIDogb3duS2V5cykob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFlbnVtZXJhYmxlT25seSB8fCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiKSBpdGVyKGtleSwgb2JqW2tleV0sIG9iaik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBpdGVyKGluZGV4LCBlbnRyeSwgb2JqKTtcbiAgICB9KTtcbiAgfVxufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBnZXRBcmNodHlwZSh0aGluZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2YXIgc3RhdGUgPSB0aGluZ1tEUkFGVF9TVEFURV07XG4gIHJldHVybiBzdGF0ZSA/IHN0YXRlLnR5cGVfID4gMyA/IHN0YXRlLnR5cGVfIC0gNCAvLyBjYXVzZSBPYmplY3QgYW5kIEFycmF5IG1hcCBiYWNrIGZyb20gNCBhbmQgNVxuICA6IHN0YXRlLnR5cGVfIC8vIG90aGVycyBhcmUgdGhlIHNhbWVcbiAgOiBBcnJheS5pc0FycmF5KHRoaW5nKSA/IDFcbiAgLyogQXJyYXkgKi9cbiAgOiBpc01hcCh0aGluZykgPyAyXG4gIC8qIE1hcCAqL1xuICA6IGlzU2V0KHRoaW5nKSA/IDNcbiAgLyogU2V0ICovXG4gIDogMFxuICAvKiBPYmplY3QgKi9cbiAgO1xufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBoYXModGhpbmcsIHByb3ApIHtcbiAgcmV0dXJuIGdldEFyY2h0eXBlKHRoaW5nKSA9PT0gMlxuICAvKiBNYXAgKi9cbiAgPyB0aGluZy5oYXMocHJvcCkgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpbmcsIHByb3ApO1xufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBnZXQodGhpbmcsIHByb3ApIHtcbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSAyXG4gIC8qIE1hcCAqL1xuICA/IHRoaW5nLmdldChwcm9wKSA6IHRoaW5nW3Byb3BdO1xufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBzZXQodGhpbmcsIHByb3BPck9sZFZhbHVlLCB2YWx1ZSkge1xuICB2YXIgdCA9IGdldEFyY2h0eXBlKHRoaW5nKTtcbiAgaWYgKHQgPT09IDJcbiAgLyogTWFwICovXG4gICkgdGhpbmcuc2V0KHByb3BPck9sZFZhbHVlLCB2YWx1ZSk7ZWxzZSBpZiAodCA9PT0gM1xuICAvKiBTZXQgKi9cbiAgKSB7XG4gICAgICB0aGluZy5hZGQodmFsdWUpO1xuICAgIH0gZWxzZSB0aGluZ1twcm9wT3JPbGRWYWx1ZV0gPSB2YWx1ZTtcbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBGcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2M2OTkwNGE1MTFiOTAwMjY2OTM1MTY4MjIzMDYzZGQ4NzcyZGZjNDAvcGFja2FnZXMvZmJqcy9zcmMvY29yZS9zaGFsbG93RXF1YWwuanNcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBpc01hcCh0YXJnZXQpIHtcbiAgcmV0dXJuIGhhc01hcCAmJiB0YXJnZXQgaW5zdGFuY2VvZiBNYXA7XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGlzU2V0KHRhcmdldCkge1xuICByZXR1cm4gaGFzU2V0ICYmIHRhcmdldCBpbnN0YW5jZW9mIFNldDtcbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gbGF0ZXN0KHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5jb3B5XyB8fCBzdGF0ZS5iYXNlXztcbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gc2hhbGxvd0NvcHkoYmFzZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiYXNlKSkgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJhc2UpO1xuICB2YXIgZGVzY3JpcHRvcnMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGJhc2UpO1xuICBkZWxldGUgZGVzY3JpcHRvcnNbRFJBRlRfU1RBVEVdO1xuICB2YXIga2V5cyA9IG93bktleXMoZGVzY3JpcHRvcnMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIHZhciBkZXNjID0gZGVzY3JpcHRvcnNba2V5XTtcblxuICAgIGlmIChkZXNjLndyaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgfSAvLyBsaWtlIG9iamVjdC5hc3NpZ24sIHdlIHdpbGwgcmVhZCBhbnkgX293bl8sIGdldC9zZXQgYWNjZXNzb3JzLiBUaGlzIGhlbHBzIGluIGRlYWxpbmdcbiAgICAvLyB3aXRoIGxpYnJhcmllcyB0aGF0IHRyYXAgdmFsdWVzLCBsaWtlIG1vYnggb3IgdnVlXG4gICAgLy8gdW5saWtlIG9iamVjdC5hc3NpZ24sIG5vbi1lbnVtZXJhYmxlcyB3aWxsIGJlIGNvcGllZCBhcyB3ZWxsXG5cblxuICAgIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgZGVzY3JpcHRvcnNba2V5XSA9IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZGVzYy5lbnVtZXJhYmxlLFxuICAgICAgdmFsdWU6IGJhc2Vba2V5XVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZSksIGRlc2NyaXB0b3JzKTtcbn1cbmZ1bmN0aW9uIGZyZWV6ZShvYmosIGRlZXApIHtcbiAgaWYgKGRlZXAgPT09IHZvaWQgMCkge1xuICAgIGRlZXAgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0Zyb3plbihvYmopIHx8IGlzRHJhZnQob2JqKSB8fCAhaXNEcmFmdGFibGUob2JqKSkgcmV0dXJuIG9iajtcblxuICBpZiAoZ2V0QXJjaHR5cGUob2JqKSA+IDFcbiAgLyogTWFwIG9yIFNldCAqL1xuICApIHtcbiAgICAgIG9iai5zZXQgPSBvYmouYWRkID0gb2JqLmNsZWFyID0gb2JqLmRlbGV0ZSA9IGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucztcbiAgICB9XG5cbiAgT2JqZWN0LmZyZWV6ZShvYmopO1xuICBpZiAoZGVlcCkgZWFjaChvYmosIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZyZWV6ZSh2YWx1ZSwgdHJ1ZSk7XG4gIH0sIHRydWUpO1xuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnMoKSB7XG4gIGRpZSgyKTtcbn1cblxuZnVuY3Rpb24gaXNGcm96ZW4ob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSByZXR1cm4gdHJ1ZTsgLy8gU2VlICM2MDAsIElFIGRpZXMgb24gbm9uLW9iamVjdHMgaW4gT2JqZWN0LmlzRnJvemVuXG5cbiAgcmV0dXJuIE9iamVjdC5pc0Zyb3plbihvYmopO1xufVxuXG4vKiogUGx1Z2luIHV0aWxpdGllcyAqL1xuXG52YXIgcGx1Z2lucyA9IHt9O1xuZnVuY3Rpb24gZ2V0UGx1Z2luKHBsdWdpbktleSkge1xuICB2YXIgcGx1Z2luID0gcGx1Z2luc1twbHVnaW5LZXldO1xuXG4gIGlmICghcGx1Z2luKSB7XG4gICAgZGllKDE4LCBwbHVnaW5LZXkpO1xuICB9IC8vIEB0cy1pZ25vcmVcblxuXG4gIHJldHVybiBwbHVnaW47XG59XG5mdW5jdGlvbiBsb2FkUGx1Z2luKHBsdWdpbktleSwgaW1wbGVtZW50YXRpb24pIHtcbiAgaWYgKCFwbHVnaW5zW3BsdWdpbktleV0pIHBsdWdpbnNbcGx1Z2luS2V5XSA9IGltcGxlbWVudGF0aW9uO1xufVxuXG52YXIgY3VycmVudFNjb3BlO1xuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuICBpZiAoICFjdXJyZW50U2NvcGUpIGRpZSgwKTtcbiAgcmV0dXJuIGN1cnJlbnRTY29wZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2NvcGUocGFyZW50XywgaW1tZXJfKSB7XG4gIHJldHVybiB7XG4gICAgZHJhZnRzXzogW10sXG4gICAgcGFyZW50XzogcGFyZW50XyxcbiAgICBpbW1lcl86IGltbWVyXyxcbiAgICAvLyBXaGVuZXZlciB0aGUgbW9kaWZpZWQgZHJhZnQgY29udGFpbnMgYSBkcmFmdCBmcm9tIGFub3RoZXIgc2NvcGUsIHdlXG4gICAgLy8gbmVlZCB0byBwcmV2ZW50IGF1dG8tZnJlZXppbmcgc28gdGhlIHVub3duZWQgZHJhZnQgY2FuIGJlIGZpbmFsaXplZC5cbiAgICBjYW5BdXRvRnJlZXplXzogdHJ1ZSxcbiAgICB1bmZpbmFsaXplZERyYWZ0c186IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpIHtcbiAgaWYgKHBhdGNoTGlzdGVuZXIpIHtcbiAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpOyAvLyBhc3NlcnQgd2UgaGF2ZSB0aGUgcGx1Z2luXG5cbiAgICBzY29wZS5wYXRjaGVzXyA9IFtdO1xuICAgIHNjb3BlLmludmVyc2VQYXRjaGVzXyA9IFtdO1xuICAgIHNjb3BlLnBhdGNoTGlzdGVuZXJfID0gcGF0Y2hMaXN0ZW5lcjtcbiAgfVxufVxuZnVuY3Rpb24gcmV2b2tlU2NvcGUoc2NvcGUpIHtcbiAgbGVhdmVTY29wZShzY29wZSk7XG4gIHNjb3BlLmRyYWZ0c18uZm9yRWFjaChyZXZva2VEcmFmdCk7IC8vIEB0cy1pZ25vcmVcblxuICBzY29wZS5kcmFmdHNfID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGxlYXZlU2NvcGUoc2NvcGUpIHtcbiAgaWYgKHNjb3BlID09PSBjdXJyZW50U2NvcGUpIHtcbiAgICBjdXJyZW50U2NvcGUgPSBzY29wZS5wYXJlbnRfO1xuICB9XG59XG5mdW5jdGlvbiBlbnRlclNjb3BlKGltbWVyKSB7XG4gIHJldHVybiBjdXJyZW50U2NvcGUgPSBjcmVhdGVTY29wZShjdXJyZW50U2NvcGUsIGltbWVyKTtcbn1cblxuZnVuY3Rpb24gcmV2b2tlRHJhZnQoZHJhZnQpIHtcbiAgdmFyIHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xuICBpZiAoc3RhdGUudHlwZV8gPT09IDBcbiAgLyogUHJveHlPYmplY3QgKi9cbiAgfHwgc3RhdGUudHlwZV8gPT09IDFcbiAgLyogUHJveHlBcnJheSAqL1xuICApIHN0YXRlLnJldm9rZV8oKTtlbHNlIHN0YXRlLnJldm9rZWRfID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKSB7XG4gIHNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA9IHNjb3BlLmRyYWZ0c18ubGVuZ3RoO1xuICB2YXIgYmFzZURyYWZ0ID0gc2NvcGUuZHJhZnRzX1swXTtcbiAgdmFyIGlzUmVwbGFjZWQgPSByZXN1bHQgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgIT09IGJhc2VEcmFmdDtcbiAgaWYgKCFzY29wZS5pbW1lcl8udXNlUHJveGllc18pIGdldFBsdWdpbihcIkVTNVwiKS53aWxsRmluYWxpemVFUzVfKHNjb3BlLCByZXN1bHQsIGlzUmVwbGFjZWQpO1xuXG4gIGlmIChpc1JlcGxhY2VkKSB7XG4gICAgaWYgKGJhc2VEcmFmdFtEUkFGVF9TVEFURV0ubW9kaWZpZWRfKSB7XG4gICAgICByZXZva2VTY29wZShzY29wZSk7XG4gICAgICBkaWUoNCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRHJhZnRhYmxlKHJlc3VsdCkpIHtcbiAgICAgIC8vIEZpbmFsaXplIHRoZSByZXN1bHQgaW4gY2FzZSBpdCBjb250YWlucyAob3IgaXMpIGEgc3Vic2V0IG9mIHRoZSBkcmFmdC5cbiAgICAgIHJlc3VsdCA9IGZpbmFsaXplKHNjb3BlLCByZXN1bHQpO1xuICAgICAgaWYgKCFzY29wZS5wYXJlbnRfKSBtYXliZUZyZWV6ZShzY29wZSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUucGF0Y2hlc18pIHtcbiAgICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKGJhc2VEcmFmdFtEUkFGVF9TVEFURV0uYmFzZV8sIHJlc3VsdCwgc2NvcGUucGF0Y2hlc18sIHNjb3BlLmludmVyc2VQYXRjaGVzXyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbmFsaXplIHRoZSBiYXNlIGRyYWZ0LlxuICAgIHJlc3VsdCA9IGZpbmFsaXplKHNjb3BlLCBiYXNlRHJhZnQsIFtdKTtcbiAgfVxuXG4gIHJldm9rZVNjb3BlKHNjb3BlKTtcblxuICBpZiAoc2NvcGUucGF0Y2hlc18pIHtcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyXyhzY29wZS5wYXRjaGVzXywgc2NvcGUuaW52ZXJzZVBhdGNoZXNfKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQgIT09IE5PVEhJTkcgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplKHJvb3RTY29wZSwgdmFsdWUsIHBhdGgpIHtcbiAgLy8gRG9uJ3QgcmVjdXJzZSBpbiB0aG8gcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlc1xuICBpZiAoaXNGcm96ZW4odmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gIHZhciBzdGF0ZSA9IHZhbHVlW0RSQUZUX1NUQVRFXTsgLy8gQSBwbGFpbiBvYmplY3QsIG1pZ2h0IG5lZWQgZnJlZXppbmcsIG1pZ2h0IGNvbnRhaW4gZHJhZnRzXG5cbiAgaWYgKCFzdGF0ZSkge1xuICAgIGVhY2godmFsdWUsIGZ1bmN0aW9uIChrZXksIGNoaWxkVmFsdWUpIHtcbiAgICAgIHJldHVybiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgc3RhdGUsIHZhbHVlLCBrZXksIGNoaWxkVmFsdWUsIHBhdGgpO1xuICAgIH0sIHRydWUgLy8gU2VlICM1OTAsIGRvbid0IHJlY3Vyc2UgaW50byBub24tZW51bWVyYWJsZSBvZiBub24gZHJhZnRlZCBvYmplY3RzXG4gICAgKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gLy8gTmV2ZXIgZmluYWxpemUgZHJhZnRzIG93bmVkIGJ5IGFub3RoZXIgc2NvcGUuXG5cblxuICBpZiAoc3RhdGUuc2NvcGVfICE9PSByb290U2NvcGUpIHJldHVybiB2YWx1ZTsgLy8gVW5tb2RpZmllZCBkcmFmdCwgcmV0dXJuIHRoZSAoZnJvemVuKSBvcmlnaW5hbFxuXG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgbWF5YmVGcmVlemUocm9vdFNjb3BlLCBzdGF0ZS5iYXNlXywgdHJ1ZSk7XG4gICAgcmV0dXJuIHN0YXRlLmJhc2VfO1xuICB9IC8vIE5vdCBmaW5hbGl6ZWQgeWV0LCBsZXQncyBkbyB0aGF0IG5vd1xuXG5cbiAgaWYgKCFzdGF0ZS5maW5hbGl6ZWRfKSB7XG4gICAgc3RhdGUuZmluYWxpemVkXyA9IHRydWU7XG4gICAgc3RhdGUuc2NvcGVfLnVuZmluYWxpemVkRHJhZnRzXy0tO1xuICAgIHZhciByZXN1bHQgPSAvLyBGb3IgRVM1LCBjcmVhdGUgYSBnb29kIGNvcHkgZnJvbSB0aGUgZHJhZnQgZmlyc3QsIHdpdGggYWRkZWQga2V5cyBhbmQgd2l0aG91dCBkZWxldGVkIGtleXMuXG4gICAgc3RhdGUudHlwZV8gPT09IDRcbiAgICAvKiBFUzVPYmplY3QgKi9cbiAgICB8fCBzdGF0ZS50eXBlXyA9PT0gNVxuICAgIC8qIEVTNUFycmF5ICovXG4gICAgPyBzdGF0ZS5jb3B5XyA9IHNoYWxsb3dDb3B5KHN0YXRlLmRyYWZ0XykgOiBzdGF0ZS5jb3B5XzsgLy8gRmluYWxpemUgYWxsIGNoaWxkcmVuIG9mIHRoZSBjb3B5XG4gICAgLy8gRm9yIHNldHMgd2UgY2xvbmUgYmVmb3JlIGl0ZXJhdGluZywgb3RoZXJ3aXNlIHdlIGNhbiBnZXQgaW4gZW5kbGVzcyBsb29wIGR1ZSB0byBtb2RpZnlpbmcgZHVyaW5nIGl0ZXJhdGlvbiwgc2VlICM2MjhcbiAgICAvLyBUbyBwcmVzZXJ2ZSBpbnNlcnRpb24gb3JkZXIgaW4gYWxsIGNhc2VzIHdlIHRoZW4gY2xlYXIgdGhlIHNldFxuICAgIC8vIEFuZCB3ZSBsZXQgZmluYWxpemVQcm9wZXJ0eSBrbm93IGl0IG5lZWRzIHRvIHJlLWFkZCBub24tZHJhZnQgY2hpbGRyZW4gYmFjayB0byB0aGUgdGFyZ2V0XG5cbiAgICB2YXIgcmVzdWx0RWFjaCA9IHJlc3VsdDtcbiAgICB2YXIgaXNTZXQgPSBmYWxzZTtcblxuICAgIGlmIChzdGF0ZS50eXBlXyA9PT0gM1xuICAgIC8qIFNldCAqL1xuICAgICkge1xuICAgICAgICByZXN1bHRFYWNoID0gbmV3IFNldChyZXN1bHQpO1xuICAgICAgICByZXN1bHQuY2xlYXIoKTtcbiAgICAgICAgaXNTZXQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgZWFjaChyZXN1bHRFYWNoLCBmdW5jdGlvbiAoa2V5LCBjaGlsZFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCByZXN1bHQsIGtleSwgY2hpbGRWYWx1ZSwgcGF0aCwgaXNTZXQpO1xuICAgIH0pOyAvLyBldmVyeXRoaW5nIGluc2lkZSBpcyBmcm96ZW4sIHdlIGNhbiBmcmVlemUgaGVyZVxuXG4gICAgbWF5YmVGcmVlemUocm9vdFNjb3BlLCByZXN1bHQsIGZhbHNlKTsgLy8gZmlyc3QgdGltZSBmaW5hbGl6aW5nLCBsZXQncyBjcmVhdGUgdGhvc2UgcGF0Y2hlc1xuXG4gICAgaWYgKHBhdGggJiYgcm9vdFNjb3BlLnBhdGNoZXNfKSB7XG4gICAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUGF0Y2hlc18oc3RhdGUsIHBhdGgsIHJvb3RTY29wZS5wYXRjaGVzXywgcm9vdFNjb3BlLmludmVyc2VQYXRjaGVzXyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmNvcHlfO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgcGFyZW50U3RhdGUsIHRhcmdldE9iamVjdCwgcHJvcCwgY2hpbGRWYWx1ZSwgcm9vdFBhdGgsIHRhcmdldElzU2V0KSB7XG4gIGlmICggY2hpbGRWYWx1ZSA9PT0gdGFyZ2V0T2JqZWN0KSBkaWUoNSk7XG5cbiAgaWYgKGlzRHJhZnQoY2hpbGRWYWx1ZSkpIHtcbiAgICB2YXIgcGF0aCA9IHJvb3RQYXRoICYmIHBhcmVudFN0YXRlICYmIHBhcmVudFN0YXRlLnR5cGVfICE9PSAzXG4gICAgLyogU2V0ICovXG4gICAgJiYgLy8gU2V0IG9iamVjdHMgYXJlIGF0b21pYyBzaW5jZSB0aGV5IGhhdmUgbm8ga2V5cy5cbiAgICAhaGFzKHBhcmVudFN0YXRlLmFzc2lnbmVkXywgcHJvcCkgLy8gU2tpcCBkZWVwIHBhdGNoZXMgZm9yIGFzc2lnbmVkIGtleXMuXG4gICAgPyByb290UGF0aC5jb25jYXQocHJvcCkgOiB1bmRlZmluZWQ7IC8vIERyYWZ0cyBvd25lZCBieSBgc2NvcGVgIGFyZSBmaW5hbGl6ZWQgaGVyZS5cblxuICAgIHZhciByZXMgPSBmaW5hbGl6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUsIHBhdGgpO1xuICAgIHNldCh0YXJnZXRPYmplY3QsIHByb3AsIHJlcyk7IC8vIERyYWZ0cyBmcm9tIGFub3RoZXIgc2NvcGUgbXVzdCBwcmV2ZW50ZWQgdG8gYmUgZnJvemVuXG4gICAgLy8gaWYgd2UgZ290IGEgZHJhZnQgYmFjayBmcm9tIGZpbmFsaXplLCB3ZSdyZSBpbiBhIG5lc3RlZCBwcm9kdWNlIGFuZCBzaG91bGRuJ3QgZnJlZXplXG5cbiAgICBpZiAoaXNEcmFmdChyZXMpKSB7XG4gICAgICByb290U2NvcGUuY2FuQXV0b0ZyZWV6ZV8gPSBmYWxzZTtcbiAgICB9IGVsc2UgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHRhcmdldElzU2V0KSB7XG4gICAgdGFyZ2V0T2JqZWN0LmFkZChjaGlsZFZhbHVlKTtcbiAgfSAvLyBTZWFyY2ggbmV3IG9iamVjdHMgZm9yIHVuZmluYWxpemVkIGRyYWZ0cy4gRnJvemVuIG9iamVjdHMgc2hvdWxkIG5ldmVyIGNvbnRhaW4gZHJhZnRzLlxuXG5cbiAgaWYgKGlzRHJhZnRhYmxlKGNoaWxkVmFsdWUpICYmICFpc0Zyb3plbihjaGlsZFZhbHVlKSkge1xuICAgIGlmICghcm9vdFNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiByb290U2NvcGUudW5maW5hbGl6ZWREcmFmdHNfIDwgMSkge1xuICAgICAgLy8gb3B0aW1pemF0aW9uOiBpZiBhbiBvYmplY3QgaXMgbm90IGEgZHJhZnQsIGFuZCB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAvLyBkZWVwZnJlZXplIGV2ZXJ5dGhpbmcsIGFuZCB3ZSBhcmUgc3VyZSB0aGF0IG5vIGRyYWZ0cyBhcmUgbGVmdCBpbiB0aGUgcmVtYWluaW5nIG9iamVjdFxuICAgICAgLy8gY2F1c2Ugd2Ugc2F3IGFuZCBmaW5hbGl6ZWQgYWxsIGRyYWZ0cyBhbHJlYWR5OyB3ZSBjYW4gc3RvcCB2aXNpdGluZyB0aGUgcmVzdCBvZiB0aGUgdHJlZS5cbiAgICAgIC8vIFRoaXMgYmVuZWZpdHMgZXNwZWNpYWxseSBhZGRpbmcgbGFyZ2UgZGF0YSB0cmVlJ3Mgd2l0aG91dCBmdXJ0aGVyIHByb2Nlc3NpbmcuXG4gICAgICAvLyBTZWUgYWRkLWRhdGEuanMgcGVyZiB0ZXN0XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlKTsgLy8gaW1tZXIgZGVlcCBmcmVlemVzIHBsYWluIG9iamVjdHMsIHNvIGlmIHRoZXJlIGlzIG5vIHBhcmVudCBzdGF0ZSwgd2UgZnJlZXplIGFzIHdlbGxcblxuICAgIGlmICghcGFyZW50U3RhdGUgfHwgIXBhcmVudFN0YXRlLnNjb3BlXy5wYXJlbnRfKSBtYXliZUZyZWV6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlRnJlZXplKHNjb3BlLCB2YWx1ZSwgZGVlcCkge1xuICBpZiAoZGVlcCA9PT0gdm9pZCAwKSB7XG4gICAgZGVlcCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gd2UgbmV2ZXIgZnJlZXplIGZvciBhIG5vbi1yb290IHNjb3BlOyBhcyBpdCB3b3VsZCBwcmV2ZW50IHBydW5pbmcgZm9yIGRyYWZ0cyBpbnNpZGUgd3JhcHBpbmcgb2JqZWN0c1xuICBpZiAoIXNjb3BlLnBhcmVudF8gJiYgc2NvcGUuaW1tZXJfLmF1dG9GcmVlemVfICYmIHNjb3BlLmNhbkF1dG9GcmVlemVfKSB7XG4gICAgZnJlZXplKHZhbHVlLCBkZWVwKTtcbiAgfVxufVxuXG4vKipcclxuICogUmV0dXJucyBhIG5ldyBkcmFmdCBvZiB0aGUgYGJhc2VgIG9iamVjdC5cclxuICpcclxuICogVGhlIHNlY29uZCBhcmd1bWVudCBpcyB0aGUgcGFyZW50IGRyYWZ0LXN0YXRlICh1c2VkIGludGVybmFsbHkpLlxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlUHJveHlQcm94eShiYXNlLCBwYXJlbnQpIHtcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGJhc2UpO1xuICB2YXIgc3RhdGUgPSB7XG4gICAgdHlwZV86IGlzQXJyYXkgPyAxXG4gICAgLyogUHJveHlBcnJheSAqL1xuICAgIDogMFxuICAgIC8qIFByb3h5T2JqZWN0ICovXG4gICAgLFxuICAgIC8vIFRyYWNrIHdoaWNoIHByb2R1Y2UgY2FsbCB0aGlzIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAvLyBUcnVlIGZvciBib3RoIHNoYWxsb3cgYW5kIGRlZXAgY2hhbmdlcy5cbiAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgIC8vIFVzZWQgZHVyaW5nIGZpbmFsaXphdGlvbi5cbiAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAvLyBUcmFjayB3aGljaCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBhc3NpZ25lZCAodHJ1ZSkgb3IgZGVsZXRlZCAoZmFsc2UpLlxuICAgIGFzc2lnbmVkXzoge30sXG4gICAgLy8gVGhlIHBhcmVudCBkcmFmdCBzdGF0ZS5cbiAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgLy8gVGhlIGJhc2Ugc3RhdGUuXG4gICAgYmFzZV86IGJhc2UsXG4gICAgLy8gVGhlIGJhc2UgcHJveHkuXG4gICAgZHJhZnRfOiBudWxsLFxuICAgIC8vIFRoZSBiYXNlIGNvcHkgd2l0aCBhbnkgdXBkYXRlZCB2YWx1ZXMuXG4gICAgY29weV86IG51bGwsXG4gICAgLy8gQ2FsbGVkIGJ5IHRoZSBgcHJvZHVjZWAgZnVuY3Rpb24uXG4gICAgcmV2b2tlXzogbnVsbCxcbiAgICBpc01hbnVhbF86IGZhbHNlXG4gIH07IC8vIHRoZSB0cmFwcyBtdXN0IHRhcmdldCBzb21ldGhpbmcsIGEgYml0IGxpa2UgdGhlICdyZWFsJyBiYXNlLlxuICAvLyBidXQgYWxzbywgd2UgbmVlZCB0byBiZSBhYmxlIHRvIGRldGVybWluZSBmcm9tIHRoZSB0YXJnZXQgd2hhdCB0aGUgcmVsZXZhbnQgc3RhdGUgaXNcbiAgLy8gKHRvIGF2b2lkIGNyZWF0aW5nIHRyYXBzIHBlciBpbnN0YW5jZSB0byBjYXB0dXJlIHRoZSBzdGF0ZSBpbiBjbG9zdXJlLFxuICAvLyBhbmQgdG8gYXZvaWQgY3JlYXRpbmcgd2VpcmQgaGlkZGVuIHByb3BlcnRpZXMgYXMgd2VsbClcbiAgLy8gU28gdGhlIHRyaWNrIGlzIHRvIHVzZSAnc3RhdGUnIGFzIHRoZSBhY3R1YWwgJ3RhcmdldCchIChhbmQgbWFrZSBzdXJlIHdlIGludGVyY2VwdCBldmVyeXRoaW5nKVxuICAvLyBOb3RlIHRoYXQgaW4gdGhlIGNhc2Ugb2YgYW4gYXJyYXksIHdlIHB1dCB0aGUgc3RhdGUgaW4gYW4gYXJyYXkgdG8gaGF2ZSBiZXR0ZXIgUmVmbGVjdCBkZWZhdWx0cyBvb3RiXG5cbiAgdmFyIHRhcmdldCA9IHN0YXRlO1xuICB2YXIgdHJhcHMgPSBvYmplY3RUcmFwcztcblxuICBpZiAoaXNBcnJheSkge1xuICAgIHRhcmdldCA9IFtzdGF0ZV07XG4gICAgdHJhcHMgPSBhcnJheVRyYXBzO1xuICB9XG5cbiAgdmFyIF9Qcm94eSRyZXZvY2FibGUgPSBQcm94eS5yZXZvY2FibGUodGFyZ2V0LCB0cmFwcyksXG4gICAgICByZXZva2UgPSBfUHJveHkkcmV2b2NhYmxlLnJldm9rZSxcbiAgICAgIHByb3h5ID0gX1Byb3h5JHJldm9jYWJsZS5wcm94eTtcblxuICBzdGF0ZS5kcmFmdF8gPSBwcm94eTtcbiAgc3RhdGUucmV2b2tlXyA9IHJldm9rZTtcbiAgcmV0dXJuIHByb3h5O1xufVxuLyoqXHJcbiAqIE9iamVjdCBkcmFmdHNcclxuICovXG5cbnZhciBvYmplY3RUcmFwcyA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoc3RhdGUsIHByb3ApIHtcbiAgICBpZiAocHJvcCA9PT0gRFJBRlRfU1RBVEUpIHJldHVybiBzdGF0ZTtcbiAgICB2YXIgc291cmNlID0gbGF0ZXN0KHN0YXRlKTtcblxuICAgIGlmICghaGFzKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgIC8vIG5vbi1leGlzdGluZyBvciBub24tb3duIHByb3BlcnR5Li4uXG4gICAgICByZXR1cm4gcmVhZFByb3BGcm9tUHJvdG8oc3RhdGUsIHNvdXJjZSwgcHJvcCk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BdO1xuXG4gICAgaWYgKHN0YXRlLmZpbmFsaXplZF8gfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIGRyYWZ0IGluIG1vZGlmaWVkIHN0YXRlLlxuICAgIC8vIEFzc2lnbmVkIHZhbHVlcyBhcmUgbmV2ZXIgZHJhZnRlZC4gVGhpcyBjYXRjaGVzIGFueSBkcmFmdHMgd2UgY3JlYXRlZCwgdG9vLlxuXG5cbiAgICBpZiAodmFsdWUgPT09IHBlZWsoc3RhdGUuYmFzZV8sIHByb3ApKSB7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV9bcHJvcF0gPSBjcmVhdGVQcm94eShzdGF0ZS5zY29wZV8uaW1tZXJfLCB2YWx1ZSwgc3RhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbiBoYXMoc3RhdGUsIHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCBpbiBsYXRlc3Qoc3RhdGUpO1xuICB9LFxuICBvd25LZXlzOiBmdW5jdGlvbiBvd25LZXlzKHN0YXRlKSB7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhsYXRlc3Qoc3RhdGUpKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUsIHByb3BcbiAgLyogc3RyaWN0bHkgbm90LCBidXQgaGVscHMgVFMgKi9cbiAgLCB2YWx1ZSkge1xuICAgIHZhciBkZXNjID0gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhsYXRlc3Qoc3RhdGUpLCBwcm9wKTtcblxuICAgIGlmIChkZXNjID09PSBudWxsIHx8IGRlc2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlc2Muc2V0KSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2U6IGlmIHRoaXMgd3JpdGUgaXMgY2FwdHVyZWQgYnkgYSBzZXR0ZXIsIHdlIGhhdmVcbiAgICAgIC8vIHRvIHRyaWdnZXIgaXQgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gICAgICBkZXNjLnNldC5jYWxsKHN0YXRlLmRyYWZ0XywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICAgIC8vIHRoZSBsYXN0IGNoZWNrIGlzIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIHNldHRpbmcgYSBub24tZXhpc3RpbmcgdG8gdW5kZWZpbmVkICh3aGljaCBpcyBhIGNoYW5nZSlcbiAgICAgIC8vIGZyb20gc2V0dGluZyBhbiBleGlzdGluZyBwcm9wZXJ0eSB3aXRoIHZhbHVlIHVuZGVmaW5lZCB0byB1bmRlZmluZWQgKHdoaWNoIGlzIG5vdCBhIGNoYW5nZSlcbiAgICAgIHZhciBjdXJyZW50ID0gcGVlayhsYXRlc3Qoc3RhdGUpLCBwcm9wKTsgLy8gc3BlY2lhbCBjYXNlLCBpZiB3ZSBhc3NpZ25pbmcgdGhlIG9yaWdpbmFsIHZhbHVlIHRvIGEgZHJhZnQsIHdlIGNhbiBpZ25vcmUgdGhlIGFzc2lnbm1lbnRcblxuICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFtEUkFGVF9TVEFURV07XG5cbiAgICAgIGlmIChjdXJyZW50U3RhdGUgJiYgY3VycmVudFN0YXRlLmJhc2VfID09PSB2YWx1ZSkge1xuICAgICAgICBzdGF0ZS5jb3B5X1twcm9wXSA9IHZhbHVlO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpcyh2YWx1ZSwgY3VycmVudCkgJiYgKHZhbHVlICE9PSB1bmRlZmluZWQgfHwgaGFzKHN0YXRlLmJhc2VfLCBwcm9wKSkpIHJldHVybiB0cnVlO1xuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5jb3B5X1twcm9wXSA9PT0gdmFsdWUgJiYgKCAvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBuZXcgcHJvcHMgd2l0aCB2YWx1ZSAndW5kZWZpbmVkJ1xuICAgIHZhbHVlICE9PSB1bmRlZmluZWQgfHwgcHJvcCBpbiBzdGF0ZS5jb3B5XykgfHwgLy8gc3BlY2lhbCBjYXNlOiBOYU5cbiAgICBOdW1iZXIuaXNOYU4odmFsdWUpICYmIE51bWJlci5pc05hTihzdGF0ZS5jb3B5X1twcm9wXSkpIHJldHVybiB0cnVlOyAvLyBAdHMtaWdub3JlXG5cbiAgICBzdGF0ZS5jb3B5X1twcm9wXSA9IHZhbHVlO1xuICAgIHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eShzdGF0ZSwgcHJvcCkge1xuICAgIC8vIFRoZSBgdW5kZWZpbmVkYCBjaGVjayBpcyBhIGZhc3QgcGF0aCBmb3IgcHJlLWV4aXN0aW5nIGtleXMuXG4gICAgaWYgKHBlZWsoc3RhdGUuYmFzZV8sIHByb3ApICE9PSB1bmRlZmluZWQgfHwgcHJvcCBpbiBzdGF0ZS5iYXNlXykge1xuICAgICAgc3RhdGUuYXNzaWduZWRfW3Byb3BdID0gZmFsc2U7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFuIG9yaWdpbmFsbHkgbm90IGFzc2lnbmVkIHByb3BlcnR5IHdhcyBkZWxldGVkXG4gICAgICBkZWxldGUgc3RhdGUuYXNzaWduZWRfW3Byb3BdO1xuICAgIH0gLy8gQHRzLWlnbm9yZVxuXG5cbiAgICBpZiAoc3RhdGUuY29weV8pIGRlbGV0ZSBzdGF0ZS5jb3B5X1twcm9wXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gTm90ZTogV2UgbmV2ZXIgY29lcmNlIGBkZXNjLnZhbHVlYCBpbnRvIGFuIEltbWVyIGRyYWZ0LCBiZWNhdXNlIHdlIGNhbid0IG1ha2VcbiAgLy8gdGhlIHNhbWUgZ3VhcmFudGVlIGluIEVTNSBtb2RlLlxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzdGF0ZSwgcHJvcCkge1xuICAgIHZhciBvd25lciA9IGxhdGVzdChzdGF0ZSk7XG4gICAgdmFyIGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvd25lciwgcHJvcCk7XG4gICAgaWYgKCFkZXNjKSByZXR1cm4gZGVzYztcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHN0YXRlLnR5cGVfICE9PSAxXG4gICAgICAvKiBQcm94eUFycmF5ICovXG4gICAgICB8fCBwcm9wICE9PSBcImxlbmd0aFwiLFxuICAgICAgZW51bWVyYWJsZTogZGVzYy5lbnVtZXJhYmxlLFxuICAgICAgdmFsdWU6IG93bmVyW3Byb3BdXG4gICAgfTtcbiAgfSxcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KCkge1xuICAgIGRpZSgxMSk7XG4gIH0sXG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihzdGF0ZSkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3RhdGUuYmFzZV8pO1xuICB9LFxuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoKSB7XG4gICAgZGllKDEyKTtcbiAgfVxufTtcbi8qKlxyXG4gKiBBcnJheSBkcmFmdHNcclxuICovXG5cbnZhciBhcnJheVRyYXBzID0ge307XG5lYWNoKG9iamVjdFRyYXBzLCBmdW5jdGlvbiAoa2V5LCBmbikge1xuICAvLyBAdHMtaWdub3JlXG4gIGFycmF5VHJhcHNba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICBhcmd1bWVudHNbMF0gPSBhcmd1bWVudHNbMF1bMF07XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KTtcblxuYXJyYXlUcmFwcy5kZWxldGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChzdGF0ZSwgcHJvcCkge1xuICBpZiAoIGlzTmFOKHBhcnNlSW50KHByb3ApKSkgZGllKDEzKTsgLy8gQHRzLWlnbm9yZVxuXG4gIHJldHVybiBhcnJheVRyYXBzLnNldC5jYWxsKHRoaXMsIHN0YXRlLCBwcm9wLCB1bmRlZmluZWQpO1xufTtcblxuYXJyYXlUcmFwcy5zZXQgPSBmdW5jdGlvbiAoc3RhdGUsIHByb3AsIHZhbHVlKSB7XG4gIGlmICggcHJvcCAhPT0gXCJsZW5ndGhcIiAmJiBpc05hTihwYXJzZUludChwcm9wKSkpIGRpZSgxNCk7XG4gIHJldHVybiBvYmplY3RUcmFwcy5zZXQuY2FsbCh0aGlzLCBzdGF0ZVswXSwgcHJvcCwgdmFsdWUsIHN0YXRlWzBdKTtcbn07IC8vIEFjY2VzcyBhIHByb3BlcnR5IHdpdGhvdXQgY3JlYXRpbmcgYW4gSW1tZXIgZHJhZnQuXG5cblxuZnVuY3Rpb24gcGVlayhkcmFmdCwgcHJvcCkge1xuICB2YXIgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XG4gIHZhciBzb3VyY2UgPSBzdGF0ZSA/IGxhdGVzdChzdGF0ZSkgOiBkcmFmdDtcbiAgcmV0dXJuIHNvdXJjZVtwcm9wXTtcbn1cblxuZnVuY3Rpb24gcmVhZFByb3BGcm9tUHJvdG8oc3RhdGUsIHNvdXJjZSwgcHJvcCkge1xuICB2YXIgX2Rlc2MkZ2V0O1xuXG4gIHZhciBkZXNjID0gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhzb3VyY2UsIHByb3ApO1xuICByZXR1cm4gZGVzYyA/IFwidmFsdWVcIiBpbiBkZXNjID8gZGVzYy52YWx1ZSA6IC8vIFRoaXMgaXMgYSB2ZXJ5IHNwZWNpYWwgY2FzZSwgaWYgdGhlIHByb3AgaXMgYSBnZXR0ZXIgZGVmaW5lZCBieSB0aGVcbiAgLy8gcHJvdG90eXBlLCB3ZSBzaG91bGQgaW52b2tlIGl0IHdpdGggdGhlIGRyYWZ0IGFzIGNvbnRleHQhXG4gIChfZGVzYyRnZXQgPSBkZXNjLmdldCkgPT09IG51bGwgfHwgX2Rlc2MkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGVzYyRnZXQuY2FsbChzdGF0ZS5kcmFmdF8pIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXREZXNjcmlwdG9yRnJvbVByb3RvKHNvdXJjZSwgcHJvcCkge1xuICAvLyAnaW4nIGNoZWNrcyBwcm90byFcbiAgaWYgKCEocHJvcCBpbiBzb3VyY2UpKSByZXR1cm4gdW5kZWZpbmVkO1xuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKTtcblxuICB3aGlsZSAocHJvdG8pIHtcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIHByb3ApO1xuICAgIGlmIChkZXNjKSByZXR1cm4gZGVzYztcbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBtYXJrQ2hhbmdlZChzdGF0ZSkge1xuICBpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuICAgIHN0YXRlLm1vZGlmaWVkXyA9IHRydWU7XG5cbiAgICBpZiAoc3RhdGUucGFyZW50Xykge1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUucGFyZW50Xyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlQ29weShzdGF0ZSkge1xuICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgc3RhdGUuY29weV8gPSBzaGFsbG93Q29weShzdGF0ZS5iYXNlXyk7XG4gIH1cbn1cblxudmFyIEltbWVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW1tZXIoY29uZmlnKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMudXNlUHJveGllc18gPSBoYXNQcm94aWVzO1xuICAgIHRoaXMuYXV0b0ZyZWV6ZV8gPSB0cnVlO1xuICAgIC8qKlxyXG4gICAgICogVGhlIGBwcm9kdWNlYCBmdW5jdGlvbiB0YWtlcyBhIHZhbHVlIGFuZCBhIFwicmVjaXBlIGZ1bmN0aW9uXCIgKHdob3NlXHJcbiAgICAgKiByZXR1cm4gdmFsdWUgb2Z0ZW4gZGVwZW5kcyBvbiB0aGUgYmFzZSBzdGF0ZSkuIFRoZSByZWNpcGUgZnVuY3Rpb24gaXNcclxuICAgICAqIGZyZWUgdG8gbXV0YXRlIGl0cyBmaXJzdCBhcmd1bWVudCBob3dldmVyIGl0IHdhbnRzLiBBbGwgbXV0YXRpb25zIGFyZVxyXG4gICAgICogb25seSBldmVyIGFwcGxpZWQgdG8gYSBfX2NvcHlfXyBvZiB0aGUgYmFzZSBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBQYXNzIG9ubHkgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBcImN1cnJpZWQgcHJvZHVjZXJcIiB3aGljaCByZWxpZXZlcyB5b3VcclxuICAgICAqIGZyb20gcGFzc2luZyB0aGUgcmVjaXBlIGZ1bmN0aW9uIGV2ZXJ5IHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogT25seSBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMgYXJlIG1hZGUgbXV0YWJsZS4gQWxsIG90aGVyIG9iamVjdHMgYXJlXHJcbiAgICAgKiBjb25zaWRlcmVkIHVuY29weWFibGUuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBfX2JvdW5kX18gdG8gaXRzIGBJbW1lcmAgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHthbnl9IGJhc2UgLSB0aGUgaW5pdGlhbCBzdGF0ZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVjaXBlIC0gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHByb3h5IG9mIHRoZSBiYXNlIHN0YXRlIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB3aGljaCBjYW4gYmUgZnJlZWx5IG1vZGlmaWVkXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXHJcbiAgICAgKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcclxuICAgICAqL1xuXG4gICAgdGhpcy5wcm9kdWNlID0gZnVuY3Rpb24gKGJhc2UsIHJlY2lwZSwgcGF0Y2hMaXN0ZW5lcikge1xuICAgICAgLy8gY3VycmllZCBpbnZvY2F0aW9uXG4gICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRCYXNlID0gcmVjaXBlO1xuICAgICAgICByZWNpcGUgPSBiYXNlO1xuICAgICAgICB2YXIgc2VsZiA9IF90aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3VycmllZFByb2R1Y2UoYmFzZSkge1xuICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgaWYgKGJhc2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYmFzZSA9IGRlZmF1bHRCYXNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxmLnByb2R1Y2UoYmFzZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XG4gICAgICAgICAgICB2YXIgX3JlY2lwZTtcblxuICAgICAgICAgICAgcmV0dXJuIChfcmVjaXBlID0gcmVjaXBlKS5jYWxsLmFwcGx5KF9yZWNpcGUsIFtfdGhpczIsIGRyYWZ0XS5jb25jYXQoYXJncykpO1xuICAgICAgICAgIH0pOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiByZWNpcGUgIT09IFwiZnVuY3Rpb25cIikgZGllKDYpO1xuICAgICAgaWYgKHBhdGNoTGlzdGVuZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcGF0Y2hMaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSBkaWUoNyk7XG4gICAgICB2YXIgcmVzdWx0OyAvLyBPbmx5IHBsYWluIG9iamVjdHMsIGFycmF5cywgYW5kIFwiaW1tZXJhYmxlIGNsYXNzZXNcIiBhcmUgZHJhZnRlZC5cblxuICAgICAgaWYgKGlzRHJhZnRhYmxlKGJhc2UpKSB7XG4gICAgICAgIHZhciBzY29wZSA9IGVudGVyU2NvcGUoX3RoaXMpO1xuICAgICAgICB2YXIgcHJveHkgPSBjcmVhdGVQcm94eShfdGhpcywgYmFzZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgdmFyIGhhc0Vycm9yID0gdHJ1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlY2lwZShwcm94eSk7XG4gICAgICAgICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBmaW5hbGx5IGluc3RlYWQgb2YgY2F0Y2ggKyByZXRocm93IGJldHRlciBwcmVzZXJ2ZXMgb3JpZ2luYWwgc3RhY2tcbiAgICAgICAgICBpZiAoaGFzRXJyb3IpIHJldm9rZVNjb3BlKHNjb3BlKTtlbHNlIGxlYXZlU2NvcGUoc2NvcGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICByZXZva2VTY29wZShzY29wZSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSk7XG4gICAgICB9IGVsc2UgaWYgKCFiYXNlIHx8IHR5cGVvZiBiYXNlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlY2lwZShiYXNlKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSByZXN1bHQgPSBiYXNlO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBOT1RISU5HKSByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChfdGhpcy5hdXRvRnJlZXplXykgZnJlZXplKHJlc3VsdCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHBhdGNoTGlzdGVuZXIpIHtcbiAgICAgICAgICB2YXIgcCA9IFtdO1xuICAgICAgICAgIHZhciBpcCA9IFtdO1xuICAgICAgICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKGJhc2UsIHJlc3VsdCwgcCwgaXApO1xuICAgICAgICAgIHBhdGNoTGlzdGVuZXIocCwgaXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSBkaWUoMjEsIGJhc2UpO1xuICAgIH07XG5cbiAgICB0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyA9IGZ1bmN0aW9uIChiYXNlLCByZWNpcGUpIHtcbiAgICAgIC8vIGN1cnJpZWQgaW52b2NhdGlvblxuICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMoc3RhdGUsIGZ1bmN0aW9uIChkcmFmdCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2UuYXBwbHkodm9pZCAwLCBbZHJhZnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcztcblxuICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLnByb2R1Y2UoYmFzZSwgcmVjaXBlLCBmdW5jdGlvbiAocCwgaXApIHtcbiAgICAgICAgcGF0Y2hlcyA9IHA7XG4gICAgICAgIGludmVyc2VQYXRjaGVzID0gaXA7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gW25leHRTdGF0ZSwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtyZXN1bHQsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzXTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnVzZVByb3hpZXMpID09PSBcImJvb2xlYW5cIikgdGhpcy5zZXRVc2VQcm94aWVzKGNvbmZpZy51c2VQcm94aWVzKTtcbiAgICBpZiAodHlwZW9mIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXV0b0ZyZWV6ZSkgPT09IFwiYm9vbGVhblwiKSB0aGlzLnNldEF1dG9GcmVlemUoY29uZmlnLmF1dG9GcmVlemUpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEltbWVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY3JlYXRlRHJhZnQgPSBmdW5jdGlvbiBjcmVhdGVEcmFmdChiYXNlKSB7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZShiYXNlKSkgZGllKDgpO1xuICAgIGlmIChpc0RyYWZ0KGJhc2UpKSBiYXNlID0gY3VycmVudChiYXNlKTtcbiAgICB2YXIgc2NvcGUgPSBlbnRlclNjb3BlKHRoaXMpO1xuICAgIHZhciBwcm94eSA9IGNyZWF0ZVByb3h5KHRoaXMsIGJhc2UsIHVuZGVmaW5lZCk7XG4gICAgcHJveHlbRFJBRlRfU1RBVEVdLmlzTWFudWFsXyA9IHRydWU7XG4gICAgbGVhdmVTY29wZShzY29wZSk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuXG4gIF9wcm90by5maW5pc2hEcmFmdCA9IGZ1bmN0aW9uIGZpbmlzaERyYWZ0KGRyYWZ0LCBwYXRjaExpc3RlbmVyKSB7XG4gICAgdmFyIHN0YXRlID0gZHJhZnQgJiYgZHJhZnRbRFJBRlRfU1RBVEVdO1xuXG4gICAge1xuICAgICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuaXNNYW51YWxfKSBkaWUoOSk7XG4gICAgICBpZiAoc3RhdGUuZmluYWxpemVkXykgZGllKDEwKTtcbiAgICB9XG5cbiAgICB2YXIgc2NvcGUgPSBzdGF0ZS5zY29wZV87XG4gICAgdXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpO1xuICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHVuZGVmaW5lZCwgc2NvcGUpO1xuICB9XG4gIC8qKlxyXG4gICAqIFBhc3MgdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGZyZWV6ZSBhbGwgY29waWVzIGNyZWF0ZWQgYnkgSW1tZXIuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCBhdXRvLWZyZWV6aW5nIGlzIGVuYWJsZWQuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2V0QXV0b0ZyZWV6ZSA9IGZ1bmN0aW9uIHNldEF1dG9GcmVlemUodmFsdWUpIHtcbiAgICB0aGlzLmF1dG9GcmVlemVfID0gdmFsdWU7XG4gIH1cbiAgLyoqXHJcbiAgICogUGFzcyB0cnVlIHRvIHVzZSB0aGUgRVMyMDE1IGBQcm94eWAgY2xhc3Mgd2hlbiBjcmVhdGluZyBkcmFmdHMsIHdoaWNoIGlzXHJcbiAgICogYWx3YXlzIGZhc3RlciB0aGFuIHVzaW5nIEVTNSBwcm94aWVzLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCwgZmVhdHVyZSBkZXRlY3Rpb24gaXMgdXNlZCwgc28gY2FsbGluZyB0aGlzIGlzIHJhcmVseSBuZWNlc3NhcnkuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2V0VXNlUHJveGllcyA9IGZ1bmN0aW9uIHNldFVzZVByb3hpZXModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgIWhhc1Byb3hpZXMpIHtcbiAgICAgIGRpZSgyMCk7XG4gICAgfVxuXG4gICAgdGhpcy51c2VQcm94aWVzXyA9IHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5hcHBseVBhdGNoZXMgPSBmdW5jdGlvbiBhcHBseVBhdGNoZXMoYmFzZSwgcGF0Y2hlcykge1xuICAgIC8vIElmIGEgcGF0Y2ggcmVwbGFjZXMgdGhlIGVudGlyZSBzdGF0ZSwgdGFrZSB0aGF0IHJlcGxhY2VtZW50IGFzIGJhc2VcbiAgICAvLyBiZWZvcmUgYXBwbHlpbmcgcGF0Y2hlc1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gcGF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHBhdGNoID0gcGF0Y2hlc1tpXTtcblxuICAgICAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwICYmIHBhdGNoLm9wID09PSBcInJlcGxhY2VcIikge1xuICAgICAgICBiYXNlID0gcGF0Y2gudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gSWYgdGhlcmUgd2FzIGEgcGF0Y2ggdGhhdCByZXBsYWNlZCB0aGUgZW50aXJlIHN0YXRlLCBzdGFydCBmcm9tIHRoZVxuICAgIC8vIHBhdGNoIGFmdGVyIHRoYXQuXG5cblxuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHBhdGNoZXMgPSBwYXRjaGVzLnNsaWNlKGkgKyAxKTtcbiAgICB9XG5cbiAgICB2YXIgYXBwbHlQYXRjaGVzSW1wbCA9IGdldFBsdWdpbihcIlBhdGNoZXNcIikuYXBwbHlQYXRjaGVzXztcblxuICAgIGlmIChpc0RyYWZ0KGJhc2UpKSB7XG4gICAgICAvLyBOLkI6IG5ldmVyIGhpdHMgaWYgc29tZSBwYXRjaCBhIHJlcGxhY2VtZW50LCBwYXRjaGVzIGFyZSBuZXZlciBkcmFmdHNcbiAgICAgIHJldHVybiBhcHBseVBhdGNoZXNJbXBsKGJhc2UsIHBhdGNoZXMpO1xuICAgIH0gLy8gT3RoZXJ3aXNlLCBwcm9kdWNlIGEgY29weSBvZiB0aGUgYmFzZSBzdGF0ZS5cblxuXG4gICAgcmV0dXJuIHRoaXMucHJvZHVjZShiYXNlLCBmdW5jdGlvbiAoZHJhZnQpIHtcbiAgICAgIHJldHVybiBhcHBseVBhdGNoZXNJbXBsKGRyYWZ0LCBwYXRjaGVzKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gSW1tZXI7XG59KCk7XG5mdW5jdGlvbiBjcmVhdGVQcm94eShpbW1lciwgdmFsdWUsIHBhcmVudCkge1xuICAvLyBwcmVjb25kaXRpb246IGNyZWF0ZVByb3h5IHNob3VsZCBiZSBndWFyZGVkIGJ5IGlzRHJhZnRhYmxlLCBzbyB3ZSBrbm93IHdlIGNhbiBzYWZlbHkgZHJhZnRcbiAgdmFyIGRyYWZ0ID0gaXNNYXAodmFsdWUpID8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5TWFwXyh2YWx1ZSwgcGFyZW50KSA6IGlzU2V0KHZhbHVlKSA/IGdldFBsdWdpbihcIk1hcFNldFwiKS5wcm94eVNldF8odmFsdWUsIHBhcmVudCkgOiBpbW1lci51c2VQcm94aWVzXyA/IGNyZWF0ZVByb3h5UHJveHkodmFsdWUsIHBhcmVudCkgOiBnZXRQbHVnaW4oXCJFUzVcIikuY3JlYXRlRVM1UHJveHlfKHZhbHVlLCBwYXJlbnQpO1xuICB2YXIgc2NvcGUgPSBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCk7XG4gIHNjb3BlLmRyYWZ0c18ucHVzaChkcmFmdCk7XG4gIHJldHVybiBkcmFmdDtcbn1cblxuZnVuY3Rpb24gY3VycmVudCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnQodmFsdWUpKSBkaWUoMjIsIHZhbHVlKTtcbiAgcmV0dXJuIGN1cnJlbnRJbXBsKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gY3VycmVudEltcGwodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgdmFyIHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdO1xuICB2YXIgY29weTtcbiAgdmFyIGFyY2hUeXBlID0gZ2V0QXJjaHR5cGUodmFsdWUpO1xuXG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICghc3RhdGUubW9kaWZpZWRfICYmIChzdGF0ZS50eXBlXyA8IDQgfHwgIWdldFBsdWdpbihcIkVTNVwiKS5oYXNDaGFuZ2VzXyhzdGF0ZSkpKSByZXR1cm4gc3RhdGUuYmFzZV87IC8vIE9wdGltaXphdGlvbjogYXZvaWQgZ2VuZXJhdGluZyBuZXcgZHJhZnRzIGR1cmluZyBjb3B5aW5nXG5cbiAgICBzdGF0ZS5maW5hbGl6ZWRfID0gdHJ1ZTtcbiAgICBjb3B5ID0gY29weUhlbHBlcih2YWx1ZSwgYXJjaFR5cGUpO1xuICAgIHN0YXRlLmZpbmFsaXplZF8gPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBjb3B5ID0gY29weUhlbHBlcih2YWx1ZSwgYXJjaFR5cGUpO1xuICB9XG5cbiAgZWFjaChjb3B5LCBmdW5jdGlvbiAoa2V5LCBjaGlsZFZhbHVlKSB7XG4gICAgaWYgKHN0YXRlICYmIGdldChzdGF0ZS5iYXNlXywga2V5KSA9PT0gY2hpbGRWYWx1ZSkgcmV0dXJuOyAvLyBubyBuZWVkIHRvIGNvcHkgb3Igc2VhcmNoIGluIHNvbWV0aGluZyB0aGF0IGRpZG4ndCBjaGFuZ2VcblxuICAgIHNldChjb3B5LCBrZXksIGN1cnJlbnRJbXBsKGNoaWxkVmFsdWUpKTtcbiAgfSk7IC8vIEluIHRoZSBmdXR1cmUsIHdlIG1pZ2h0IGNvbnNpZGVyIGZyZWV6aW5nIGhlcmUsIGJhc2VkIG9uIHRoZSBjdXJyZW50IHNldHRpbmdzXG5cbiAgcmV0dXJuIGFyY2hUeXBlID09PSAzXG4gIC8qIFNldCAqL1xuICA/IG5ldyBTZXQoY29weSkgOiBjb3B5O1xufVxuXG5mdW5jdGlvbiBjb3B5SGVscGVyKHZhbHVlLCBhcmNoVHlwZSkge1xuICAvLyBjcmVhdGVzIGEgc2hhbGxvdyBjb3B5LCBldmVuIGlmIGl0IGlzIGEgbWFwIG9yIHNldFxuICBzd2l0Y2ggKGFyY2hUeXBlKSB7XG4gICAgY2FzZSAyXG4gICAgLyogTWFwICovXG4gICAgOlxuICAgICAgcmV0dXJuIG5ldyBNYXAodmFsdWUpO1xuXG4gICAgY2FzZSAzXG4gICAgLyogU2V0ICovXG4gICAgOlxuICAgICAgLy8gU2V0IHdpbGwgYmUgY2xvbmVkIGFzIGFycmF5IHRlbXBvcmFyaWx5LCBzbyB0aGF0IHdlIGNhbiByZXBsYWNlIGluZGl2aWR1YWwgaXRlbXNcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBzaGFsbG93Q29weSh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGVuYWJsZUVTNSgpIHtcbiAgZnVuY3Rpb24gd2lsbEZpbmFsaXplRVM1XyhzY29wZSwgcmVzdWx0LCBpc1JlcGxhY2VkKSB7XG4gICAgaWYgKCFpc1JlcGxhY2VkKSB7XG4gICAgICBpZiAoc2NvcGUucGF0Y2hlc18pIHtcbiAgICAgICAgbWFya0NoYW5nZXNSZWN1cnNpdmVseShzY29wZS5kcmFmdHNfWzBdKTtcbiAgICAgIH0gLy8gVGhpcyBpcyBmYXN0ZXIgd2hlbiB3ZSBkb24ndCBjYXJlIGFib3V0IHdoaWNoIGF0dHJpYnV0ZXMgY2hhbmdlZC5cblxuXG4gICAgICBtYXJrQ2hhbmdlc1N3ZWVwKHNjb3BlLmRyYWZ0c18pO1xuICAgIH0gLy8gV2hlbiBhIGNoaWxkIGRyYWZ0IGlzIHJldHVybmVkLCBsb29rIGZvciBjaGFuZ2VzLlxuICAgIGVsc2UgaWYgKGlzRHJhZnQocmVzdWx0KSAmJiByZXN1bHRbRFJBRlRfU1RBVEVdLnNjb3BlXyA9PT0gc2NvcGUpIHtcbiAgICAgICAgbWFya0NoYW5nZXNTd2VlcChzY29wZS5kcmFmdHNfKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVTNURyYWZ0KGlzQXJyYXksIGJhc2UpIHtcbiAgICBpZiAoaXNBcnJheSkge1xuICAgICAgdmFyIGRyYWZ0ID0gbmV3IEFycmF5KGJhc2UubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkcmFmdCwgXCJcIiArIGksIHByb3h5UHJvcGVydHkoaSwgdHJ1ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZHJhZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfZGVzY3JpcHRvcnMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGJhc2UpO1xuXG4gICAgICBkZWxldGUgX2Rlc2NyaXB0b3JzW0RSQUZUX1NUQVRFXTtcbiAgICAgIHZhciBrZXlzID0gb3duS2V5cyhfZGVzY3JpcHRvcnMpO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwga2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbX2ldO1xuICAgICAgICBfZGVzY3JpcHRvcnNba2V5XSA9IHByb3h5UHJvcGVydHkoa2V5LCBpc0FycmF5IHx8ICEhX2Rlc2NyaXB0b3JzW2tleV0uZW51bWVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlKSwgX2Rlc2NyaXB0b3JzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFUzVQcm94eV8oYmFzZSwgcGFyZW50KSB7XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGJhc2UpO1xuICAgIHZhciBkcmFmdCA9IGNyZWF0ZUVTNURyYWZ0KGlzQXJyYXksIGJhc2UpO1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHR5cGVfOiBpc0FycmF5ID8gNVxuICAgICAgLyogRVM1QXJyYXkgKi9cbiAgICAgIDogNFxuICAgICAgLyogRVM1T2JqZWN0ICovXG4gICAgICAsXG4gICAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAgIGFzc2lnbmVkXzoge30sXG4gICAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgICAvLyBiYXNlIGlzIHRoZSBvYmplY3Qgd2UgYXJlIGRyYWZ0aW5nXG4gICAgICBiYXNlXzogYmFzZSxcbiAgICAgIC8vIGRyYWZ0IGlzIHRoZSBkcmFmdCBvYmplY3QgaXRzZWxmLCB0aGF0IHRyYXBzIGFsbCByZWFkcyBhbmQgcmVhZHMgZnJvbSBlaXRoZXIgdGhlIGJhc2UgKGlmIHVubW9kaWZpZWQpIG9yIGNvcHkgKGlmIG1vZGlmaWVkKVxuICAgICAgZHJhZnRfOiBkcmFmdCxcbiAgICAgIGNvcHlfOiBudWxsLFxuICAgICAgcmV2b2tlZF86IGZhbHNlLFxuICAgICAgaXNNYW51YWxfOiBmYWxzZVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRyYWZ0LCBEUkFGVF9TVEFURSwge1xuICAgICAgdmFsdWU6IHN0YXRlLFxuICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UgPC0gdGhlIGRlZmF1bHRcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGRyYWZ0O1xuICB9IC8vIHByb3BlcnR5IGRlc2NyaXB0b3JzIGFyZSByZWN5Y2xlZCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgY3JlYXRlIGEgZ2V0IGFuZCBzZXQgY2xvc3VyZSBwZXIgcHJvcGVydHksXG4gIC8vIGJ1dCBzaGFyZSB0aGVtIGFsbCBpbnN0ZWFkXG5cblxuICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcblxuICBmdW5jdGlvbiBwcm94eVByb3BlcnR5KHByb3AsIGVudW1lcmFibGUpIHtcbiAgICB2YXIgZGVzYyA9IGRlc2NyaXB0b3JzW3Byb3BdO1xuXG4gICAgaWYgKGRlc2MpIHtcbiAgICAgIGRlc2MuZW51bWVyYWJsZSA9IGVudW1lcmFibGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc2NyaXB0b3JzW3Byb3BdID0gZGVzYyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBlbnVtZXJhYmxlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgICAgICByZXR1cm4gb2JqZWN0VHJhcHMuZ2V0KHN0YXRlLCBwcm9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgICAgICBvYmplY3RUcmFwcy5zZXQoc3RhdGUsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzYztcbiAgfSAvLyBUaGlzIGxvb2tzIGV4cGVuc2l2ZSwgYnV0IG9ubHkgcHJveGllcyBhcmUgdmlzaXRlZCwgYW5kIG9ubHkgb2JqZWN0cyB3aXRob3V0IGtub3duIGNoYW5nZXMgYXJlIHNjYW5uZWQuXG5cblxuICBmdW5jdGlvbiBtYXJrQ2hhbmdlc1N3ZWVwKGRyYWZ0cykge1xuICAgIC8vIFRoZSBuYXR1cmFsIG9yZGVyIG9mIGRyYWZ0cyBpbiB0aGUgYHNjb3BlYCBhcnJheSBpcyBiYXNlZCBvbiB3aGVuIHRoZXlcbiAgICAvLyB3ZXJlIGFjY2Vzc2VkLiBCeSBwcm9jZXNzaW5nIGRyYWZ0cyBpbiByZXZlcnNlIG5hdHVyYWwgb3JkZXIsIHdlIGhhdmUgYVxuICAgIC8vIGJldHRlciBjaGFuY2Ugb2YgcHJvY2Vzc2luZyBsZWFmIG5vZGVzIGZpcnN0LiBXaGVuIGEgbGVhZiBub2RlIGlzIGtub3duIHRvXG4gICAgLy8gaGF2ZSBjaGFuZ2VkLCB3ZSBjYW4gYXZvaWQgYW55IHRyYXZlcnNhbCBvZiBpdHMgYW5jZXN0b3Igbm9kZXMuXG4gICAgZm9yICh2YXIgaSA9IGRyYWZ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHN0YXRlID0gZHJhZnRzW2ldW0RSQUZUX1NUQVRFXTtcblxuICAgICAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICAgICAgc3dpdGNoIChzdGF0ZS50eXBlXykge1xuICAgICAgICAgIGNhc2UgNVxuICAgICAgICAgIC8qIEVTNUFycmF5ICovXG4gICAgICAgICAgOlxuICAgICAgICAgICAgaWYgKGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSkpIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA0XG4gICAgICAgICAgLyogRVM1T2JqZWN0ICovXG4gICAgICAgICAgOlxuICAgICAgICAgICAgaWYgKGhhc09iamVjdENoYW5nZXMoc3RhdGUpKSBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkob2JqZWN0KSB7XG4gICAgaWYgKCFvYmplY3QgfHwgdHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIikgcmV0dXJuO1xuICAgIHZhciBzdGF0ZSA9IG9iamVjdFtEUkFGVF9TVEFURV07XG4gICAgaWYgKCFzdGF0ZSkgcmV0dXJuO1xuICAgIHZhciBiYXNlXyA9IHN0YXRlLmJhc2VfLFxuICAgICAgICBkcmFmdF8gPSBzdGF0ZS5kcmFmdF8sXG4gICAgICAgIGFzc2lnbmVkXyA9IHN0YXRlLmFzc2lnbmVkXyxcbiAgICAgICAgdHlwZV8gPSBzdGF0ZS50eXBlXztcblxuICAgIGlmICh0eXBlXyA9PT0gNFxuICAgIC8qIEVTNU9iamVjdCAqL1xuICAgICkge1xuICAgICAgICAvLyBMb29rIGZvciBhZGRlZCBrZXlzLlxuICAgICAgICAvLyBwcm9iYWJseSB0aGVyZSBpcyBhIGZhc3RlciB3YXkgdG8gZGV0ZWN0IGNoYW5nZXMsIGFzIHN3ZWVwICsgcmVjdXJzZSBzZWVtcyB0byBkbyBzb21lXG4gICAgICAgIC8vIHVubmVjZXNzYXJ5IHdvcmsuXG4gICAgICAgIC8vIGFsc286IHByb2JhYmx5IHdlIGNhbiBzdG9yZSB0aGUgaW5mb3JtYXRpb24gd2UgZGV0ZWN0IGhlcmUsIHRvIHNwZWVkIHVwIHRyZWUgZmluYWxpemF0aW9uIVxuICAgICAgICBlYWNoKGRyYWZ0XywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIGlmIChrZXkgPT09IERSQUZUX1NUQVRFKSByZXR1cm47IC8vIFRoZSBgdW5kZWZpbmVkYCBjaGVjayBpcyBhIGZhc3QgcGF0aCBmb3IgcHJlLWV4aXN0aW5nIGtleXMuXG5cbiAgICAgICAgICBpZiAoYmFzZV9ba2V5XSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZV8sIGtleSkpIHtcbiAgICAgICAgICAgIGFzc2lnbmVkX1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFhc3NpZ25lZF9ba2V5XSkge1xuICAgICAgICAgICAgLy8gT25seSB1bnRvdWNoZWQgcHJvcGVydGllcyB0cmlnZ2VyIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgIG1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkoZHJhZnRfW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIExvb2sgZm9yIHJlbW92ZWQga2V5cy5cblxuICAgICAgICBlYWNoKGJhc2VfLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgLy8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cbiAgICAgICAgICBpZiAoZHJhZnRfW2tleV0gPT09IHVuZGVmaW5lZCAmJiAhaGFzKGRyYWZ0Xywga2V5KSkge1xuICAgICAgICAgICAgYXNzaWduZWRfW2tleV0gPSBmYWxzZTtcbiAgICAgICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlXyA9PT0gNVxuICAgIC8qIEVTNUFycmF5ICovXG4gICAgKSB7XG4gICAgICAgIGlmIChoYXNBcnJheUNoYW5nZXMoc3RhdGUpKSB7XG4gICAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICAgIGFzc2lnbmVkXy5sZW5ndGggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYWZ0Xy5sZW5ndGggPCBiYXNlXy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gZHJhZnRfLmxlbmd0aDsgaSA8IGJhc2VfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhc3NpZ25lZF9baV0gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gYmFzZV8ubGVuZ3RoOyBfaTIgPCBkcmFmdF8ubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgYXNzaWduZWRfW19pMl0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBNaW5pbXVtIGNvdW50IGlzIGVub3VnaCwgdGhlIG90aGVyIHBhcnRzIGhhcyBiZWVuIHByb2Nlc3NlZC5cblxuXG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihkcmFmdF8ubGVuZ3RoLCBiYXNlXy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG1pbjsgX2kzKyspIHtcbiAgICAgICAgICAvLyBPbmx5IHVudG91Y2hlZCBpbmRpY2VzIHRyaWdnZXIgcmVjdXJzaW9uLlxuICAgICAgICAgIGlmICghZHJhZnRfLmhhc093blByb3BlcnR5KF9pMykpIHtcbiAgICAgICAgICAgIGFzc2lnbmVkX1tfaTNdID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXNzaWduZWRfW19pM10gPT09IHVuZGVmaW5lZCkgbWFya0NoYW5nZXNSZWN1cnNpdmVseShkcmFmdF9bX2kzXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc09iamVjdENoYW5nZXMoc3RhdGUpIHtcbiAgICB2YXIgYmFzZV8gPSBzdGF0ZS5iYXNlXyxcbiAgICAgICAgZHJhZnRfID0gc3RhdGUuZHJhZnRfOyAvLyBTZWFyY2ggZm9yIGFkZGVkIGtleXMgYW5kIGNoYW5nZWQga2V5cy4gU3RhcnQgYXQgdGhlIGJhY2ssIGJlY2F1c2VcbiAgICAvLyBub24tbnVtZXJpYyBrZXlzIGFyZSBvcmRlcmVkIGJ5IHRpbWUgb2YgZGVmaW5pdGlvbiBvbiB0aGUgb2JqZWN0LlxuXG4gICAgdmFyIGtleXMgPSBvd25LZXlzKGRyYWZ0Xyk7XG5cbiAgICBmb3IgKHZhciBpID0ga2V5cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoa2V5ID09PSBEUkFGVF9TVEFURSkgY29udGludWU7XG4gICAgICB2YXIgYmFzZVZhbHVlID0gYmFzZV9ba2V5XTsgLy8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cblxuICAgICAgaWYgKGJhc2VWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZV8sIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIE9uY2UgYSBiYXNlIGtleSBpcyBkZWxldGVkLCBmdXR1cmUgY2hhbmdlcyBnbyB1bmRldGVjdGVkLCBiZWNhdXNlIGl0c1xuICAgICAgLy8gZGVzY3JpcHRvciBpcyBlcmFzZWQuIFRoaXMgYnJhbmNoIGRldGVjdHMgYW55IG1pc3NlZCBjaGFuZ2VzLlxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZHJhZnRfW2tleV07XG5cbiAgICAgICAgICB2YXIgX3N0YXRlID0gdmFsdWUgJiYgdmFsdWVbRFJBRlRfU1RBVEVdO1xuXG4gICAgICAgICAgaWYgKF9zdGF0ZSA/IF9zdGF0ZS5iYXNlXyAhPT0gYmFzZVZhbHVlIDogIWlzKHZhbHVlLCBiYXNlVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IC8vIEF0IHRoaXMgcG9pbnQsIG5vIGtleXMgd2VyZSBhZGRlZCBvciBjaGFuZ2VkLlxuICAgIC8vIENvbXBhcmUga2V5IGNvdW50IHRvIGRldGVybWluZSBpZiBrZXlzIHdlcmUgZGVsZXRlZC5cblxuXG4gICAgdmFyIGJhc2VJc0RyYWZ0ID0gISFiYXNlX1tEUkFGVF9TVEFURV07XG4gICAgcmV0dXJuIGtleXMubGVuZ3RoICE9PSBvd25LZXlzKGJhc2VfKS5sZW5ndGggKyAoYmFzZUlzRHJhZnQgPyAwIDogMSk7IC8vICsgMSB0byBjb3JyZWN0IGZvciBEUkFGVF9TVEFURVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKSB7XG4gICAgdmFyIGRyYWZ0XyA9IHN0YXRlLmRyYWZ0XztcbiAgICBpZiAoZHJhZnRfLmxlbmd0aCAhPT0gc3RhdGUuYmFzZV8ubGVuZ3RoKSByZXR1cm4gdHJ1ZTsgLy8gU2VlICMxMTZcbiAgICAvLyBJZiB3ZSBmaXJzdCBzaG9ydGVuIHRoZSBsZW5ndGgsIG91ciBhcnJheSBpbnRlcmNlcHRvcnMgd2lsbCBiZSByZW1vdmVkLlxuICAgIC8vIElmIGFmdGVyIHRoYXQgbmV3IGl0ZW1zIGFyZSBhZGRlZCwgcmVzdWx0IGluIHRoZSBzYW1lIG9yaWdpbmFsIGxlbmd0aCxcbiAgICAvLyB0aG9zZSBsYXN0IGl0ZW1zIHdpbGwgaGF2ZSBubyBpbnRlcmNlcHRpbmcgcHJvcGVydHkuXG4gICAgLy8gU28gaWYgdGhlcmUgaXMgbm8gb3duIGRlc2NyaXB0b3Igb24gdGhlIGxhc3QgcG9zaXRpb24sIHdlIGtub3cgdGhhdCBpdGVtcyB3ZXJlIHJlbW92ZWQgYW5kIGFkZGVkXG4gICAgLy8gTi5CLjogc3BsaWNlLCB1bnNoaWZ0LCBldGMgb25seSBzaGlmdCB2YWx1ZXMgYXJvdW5kLCBidXQgbm90IHByb3AgZGVzY3JpcHRvcnMsIHNvIHdlIG9ubHkgaGF2ZSB0byBjaGVja1xuICAgIC8vIHRoZSBsYXN0IG9uZVxuICAgIC8vIGxhc3QgZGVzY3JpcHRvciBjYW4gYmUgbm90IGEgdHJhcCwgaWYgdGhlIGFycmF5IHdhcyBleHRlbmRlZFxuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRyYWZ0XywgZHJhZnRfLmxlbmd0aCAtIDEpOyAvLyBkZXNjcmlwdG9yIGNhbiBiZSBudWxsLCBidXQgb25seSBmb3IgbmV3bHkgY3JlYXRlZCBzcGFyc2UgYXJyYXlzLCBlZy4gbmV3IEFycmF5KDEwKVxuXG4gICAgaWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZ2V0KSByZXR1cm4gdHJ1ZTsgLy8gaWYgd2UgbWlzcyBhIHByb3BlcnR5LCBpdCBoYXMgYmVlbiBkZWxldGVkLCBzbyBhcnJheSBwcm9ib2JhbHkgY2hhbmdlZFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkcmFmdF8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZHJhZnRfLmhhc093blByb3BlcnR5KGkpKSByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIEZvciBhbGwgb3RoZXIgY2FzZXMsIHdlIGRvbid0IGhhdmUgdG8gY29tcGFyZSwgYXMgdGhleSB3b3VsZCBoYXZlIGJlZW4gcGlja2VkIHVwIGJ5IHRoZSBpbmRleCBzZXR0ZXJzXG5cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0NoYW5nZXNfKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLnR5cGVfID09PSA0XG4gICAgLyogRVM1T2JqZWN0ICovXG4gICAgPyBoYXNPYmplY3RDaGFuZ2VzKHN0YXRlKSA6IGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRVbnJldm9rZWQoc3RhdGVcbiAgLypFUzVTdGF0ZSB8IE1hcFN0YXRlIHwgU2V0U3RhdGUqL1xuICApIHtcbiAgICBpZiAoc3RhdGUucmV2b2tlZF8pIGRpZSgzLCBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSk7XG4gIH1cblxuICBsb2FkUGx1Z2luKFwiRVM1XCIsIHtcbiAgICBjcmVhdGVFUzVQcm94eV86IGNyZWF0ZUVTNVByb3h5XyxcbiAgICB3aWxsRmluYWxpemVFUzVfOiB3aWxsRmluYWxpemVFUzVfLFxuICAgIGhhc0NoYW5nZXNfOiBoYXNDaGFuZ2VzX1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlUGF0Y2hlcygpIHtcbiAgdmFyIFJFUExBQ0UgPSBcInJlcGxhY2VcIjtcbiAgdmFyIEFERCA9IFwiYWRkXCI7XG4gIHZhciBSRU1PVkUgPSBcInJlbW92ZVwiO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc18oc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHN3aXRjaCAoc3RhdGUudHlwZV8pIHtcbiAgICAgIGNhc2UgMFxuICAgICAgLyogUHJveHlPYmplY3QgKi9cbiAgICAgIDpcbiAgICAgIGNhc2UgNFxuICAgICAgLyogRVM1T2JqZWN0ICovXG4gICAgICA6XG4gICAgICBjYXNlIDJcbiAgICAgIC8qIE1hcCAqL1xuICAgICAgOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuXG4gICAgICBjYXNlIDVcbiAgICAgIC8qIEVTNUFycmF5ICovXG4gICAgICA6XG4gICAgICBjYXNlIDFcbiAgICAgIC8qIFByb3h5QXJyYXkgKi9cbiAgICAgIDpcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuXG4gICAgICBjYXNlIDNcbiAgICAgIC8qIFNldCAqL1xuICAgICAgOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVTZXRQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICB2YXIgYmFzZV8gPSBzdGF0ZS5iYXNlXyxcbiAgICAgICAgYXNzaWduZWRfID0gc3RhdGUuYXNzaWduZWRfO1xuICAgIHZhciBjb3B5XyA9IHN0YXRlLmNvcHlfOyAvLyBSZWR1Y2UgY29tcGxleGl0eSBieSBlbnN1cmluZyBgYmFzZWAgaXMgbmV2ZXIgbG9uZ2VyLlxuXG4gICAgaWYgKGNvcHlfLmxlbmd0aCA8IGJhc2VfLmxlbmd0aCkge1xuICAgICAgdmFyIF9yZWYgPSBbY29weV8sIGJhc2VfXTtcbiAgICAgIGJhc2VfID0gX3JlZlswXTtcbiAgICAgIGNvcHlfID0gX3JlZlsxXTtcbiAgICAgIHZhciBfcmVmMiA9IFtpbnZlcnNlUGF0Y2hlcywgcGF0Y2hlc107XG4gICAgICBwYXRjaGVzID0gX3JlZjJbMF07XG4gICAgICBpbnZlcnNlUGF0Y2hlcyA9IF9yZWYyWzFdO1xuICAgIH0gLy8gUHJvY2VzcyByZXBsYWNlZCBpbmRpY2VzLlxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXNzaWduZWRfW2ldICYmIGNvcHlfW2ldICE9PSBiYXNlX1tpXSkge1xuICAgICAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGNvcHlfW2ldKVxuICAgICAgICB9KTtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoYmFzZV9baV0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy8gUHJvY2VzcyBhZGRlZCBpbmRpY2VzLlxuXG5cbiAgICBmb3IgKHZhciBfaSA9IGJhc2VfLmxlbmd0aDsgX2kgPCBjb3B5Xy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbX2ldKTtcblxuICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IEFERCxcbiAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgIC8vIE5lZWQgdG8gbWF5YmUgY2xvbmUgaXQsIGFzIGl0IGNhbiBpbiBmYWN0IGJlIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICAvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGNvcHlfW19pXSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChiYXNlXy5sZW5ndGggPCBjb3B5Xy5sZW5ndGgpIHtcbiAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogUkVQTEFDRSxcbiAgICAgICAgcGF0aDogYmFzZVBhdGguY29uY2F0KFtcImxlbmd0aFwiXSksXG4gICAgICAgIHZhbHVlOiBiYXNlXy5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBUaGlzIGlzIHVzZWQgZm9yIGJvdGggTWFwIG9iamVjdHMgYW5kIG5vcm1hbCBvYmplY3RzLlxuXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICB2YXIgYmFzZV8gPSBzdGF0ZS5iYXNlXyxcbiAgICAgICAgY29weV8gPSBzdGF0ZS5jb3B5XztcbiAgICBlYWNoKHN0YXRlLmFzc2lnbmVkXywgZnVuY3Rpb24gKGtleSwgYXNzaWduZWRWYWx1ZSkge1xuICAgICAgdmFyIG9yaWdWYWx1ZSA9IGdldChiYXNlXywga2V5KTtcbiAgICAgIHZhciB2YWx1ZSA9IGdldChjb3B5Xywga2V5KTtcbiAgICAgIHZhciBvcCA9ICFhc3NpZ25lZFZhbHVlID8gUkVNT1ZFIDogaGFzKGJhc2VfLCBrZXkpID8gUkVQTEFDRSA6IEFERDtcbiAgICAgIGlmIChvcmlnVmFsdWUgPT09IHZhbHVlICYmIG9wID09PSBSRVBMQUNFKSByZXR1cm47XG4gICAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChrZXkpO1xuICAgICAgcGF0Y2hlcy5wdXNoKG9wID09PSBSRU1PVkUgPyB7XG4gICAgICAgIG9wOiBvcCxcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSA6IHtcbiAgICAgICAgb3A6IG9wLFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaChvcCA9PT0gQUREID8ge1xuICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9IDogb3AgPT09IFJFTU9WRSA/IHtcbiAgICAgICAgb3A6IEFERCxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSlcbiAgICAgIH0gOiB7XG4gICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVNldFBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHZhciBiYXNlXyA9IHN0YXRlLmJhc2VfLFxuICAgICAgICBjb3B5XyA9IHN0YXRlLmNvcHlfO1xuICAgIHZhciBpID0gMDtcbiAgICBiYXNlXy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKCFjb3B5Xy5oYXModmFsdWUpKSB7XG4gICAgICAgIHZhciBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFJFTU9WRSxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XG4gICAgICAgICAgb3A6IEFERCxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH0pO1xuICAgIGkgPSAwO1xuICAgIGNvcHlfLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoIWJhc2VfLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogQURELFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcbiAgICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZVZhbHVlLCByZXBsYWNlbWVudCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHZhbHVlOiByZXBsYWNlbWVudCA9PT0gTk9USElORyA/IHVuZGVmaW5lZCA6IHJlcGxhY2VtZW50XG4gICAgfSk7XG4gICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogUkVQTEFDRSxcbiAgICAgIHBhdGg6IFtdLFxuICAgICAgdmFsdWU6IGJhc2VWYWx1ZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlQYXRjaGVzXyhkcmFmdCwgcGF0Y2hlcykge1xuICAgIHBhdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAocGF0Y2gpIHtcbiAgICAgIHZhciBwYXRoID0gcGF0Y2gucGF0aCxcbiAgICAgICAgICBvcCA9IHBhdGNoLm9wO1xuICAgICAgdmFyIGJhc2UgPSBkcmFmdDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgcGFyZW50VHlwZSA9IGdldEFyY2h0eXBlKGJhc2UpO1xuICAgICAgICB2YXIgcCA9IHBhdGhbaV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcCA9IFwiXCIgKyBwO1xuICAgICAgICB9IC8vIFNlZSAjNzM4LCBhdm9pZCBwcm90b3R5cGUgcG9sbHV0aW9uXG5cblxuICAgICAgICBpZiAoKHBhcmVudFR5cGUgPT09IDBcbiAgICAgICAgLyogT2JqZWN0ICovXG4gICAgICAgIHx8IHBhcmVudFR5cGUgPT09IDFcbiAgICAgICAgLyogQXJyYXkgKi9cbiAgICAgICAgKSAmJiAocCA9PT0gXCJfX3Byb3RvX19cIiB8fCBwID09PSBcImNvbnN0cnVjdG9yXCIpKSBkaWUoMjQpO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiBwID09PSBcInByb3RvdHlwZVwiKSBkaWUoMjQpO1xuICAgICAgICBiYXNlID0gZ2V0KGJhc2UsIHApO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2UgIT09IFwib2JqZWN0XCIpIGRpZSgxNSwgcGF0aC5qb2luKFwiL1wiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgICB2YXIgdmFsdWUgPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKHBhdGNoLnZhbHVlKTsgLy8gdXNlZCB0byBjbG9uZSBwYXRjaCB0byBlbnN1cmUgb3JpZ2luYWwgcGF0Y2ggaXMgbm90IG1vZGlmaWVkLCBzZWUgIzQxMVxuXG4gICAgICB2YXIga2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2UgUkVQTEFDRTpcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMlxuICAgICAgICAgICAgLyogTWFwICovXG4gICAgICAgICAgICA6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLnNldChrZXksIHZhbHVlKTtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgICAgICAgICAgY2FzZSAzXG4gICAgICAgICAgICAvKiBTZXQgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgZGllKDE2KTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gaWYgdmFsdWUgaXMgYW4gb2JqZWN0LCB0aGVuIGl0J3MgYXNzaWduZWQgYnkgcmVmZXJlbmNlXG4gICAgICAgICAgICAgIC8vIGluIHRoZSBmb2xsb3dpbmcgYWRkIG9yIHJlbW92ZSBvcHMsIHRoZSB2YWx1ZSBmaWVsZCBpbnNpZGUgdGhlIHBhdGNoIHdpbGwgYWxzbyBiZSBtb2RpZnllZFxuICAgICAgICAgICAgICAvLyBzbyB3ZSB1c2UgdmFsdWUgZnJvbSB0aGUgY2xvbmVkIHBhdGNoXG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIEFERDpcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMVxuICAgICAgICAgICAgLyogQXJyYXkgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gXCItXCIgPyBiYXNlLnB1c2godmFsdWUpIDogYmFzZS5zcGxpY2Uoa2V5LCAwLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIGNhc2UgMlxuICAgICAgICAgICAgLyogTWFwICovXG4gICAgICAgICAgICA6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLnNldChrZXksIHZhbHVlKTtcblxuICAgICAgICAgICAgY2FzZSAzXG4gICAgICAgICAgICAvKiBTZXQgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuYWRkKHZhbHVlKTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFTU9WRTpcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMVxuICAgICAgICAgICAgLyogQXJyYXkgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc3BsaWNlKGtleSwgMSk7XG5cbiAgICAgICAgICAgIGNhc2UgMlxuICAgICAgICAgICAgLyogTWFwICovXG4gICAgICAgICAgICA6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgICAgICBjYXNlIDNcbiAgICAgICAgICAgIC8qIFNldCAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5kZWxldGUocGF0Y2gudmFsdWUpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIGJhc2Vba2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkaWUoMTcsIG9wKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZHJhZnQ7XG4gIH1cblxuICBmdW5jdGlvbiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iaikge1xuICAgIGlmICghaXNEcmFmdGFibGUob2JqKSkgcmV0dXJuIG9iajtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gb2JqLm1hcChkZWVwQ2xvbmVQYXRjaFZhbHVlKTtcbiAgICBpZiAoaXNNYXAob2JqKSkgcmV0dXJuIG5ldyBNYXAoQXJyYXkuZnJvbShvYmouZW50cmllcygpKS5tYXAoZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICB2YXIgayA9IF9yZWYzWzBdLFxuICAgICAgICAgIHYgPSBfcmVmM1sxXTtcbiAgICAgIHJldHVybiBbaywgZGVlcENsb25lUGF0Y2hWYWx1ZSh2KV07XG4gICAgfSkpO1xuICAgIGlmIChpc1NldChvYmopKSByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKG9iaikubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpKTtcbiAgICB2YXIgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBjbG9uZWRba2V5XSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqW2tleV0pO1xuICAgIH1cblxuICAgIGlmIChoYXMob2JqLCBEUkFGVEFCTEUpKSBjbG9uZWRbRFJBRlRBQkxFXSA9IG9ialtEUkFGVEFCTEVdO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvYmopIHtcbiAgICBpZiAoaXNEcmFmdChvYmopKSB7XG4gICAgICByZXR1cm4gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmopO1xuICAgIH0gZWxzZSByZXR1cm4gb2JqO1xuICB9XG5cbiAgbG9hZFBsdWdpbihcIlBhdGNoZXNcIiwge1xuICAgIGFwcGx5UGF0Y2hlc186IGFwcGx5UGF0Y2hlc18sXG4gICAgZ2VuZXJhdGVQYXRjaGVzXzogZ2VuZXJhdGVQYXRjaGVzXyxcbiAgICBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc186IGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzX1xuICB9KTtcbn1cblxuLy8gdHlwZXMgb25seSFcbmZ1bmN0aW9uIGVuYWJsZU1hcFNldCgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdmFyIF9leHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gZXh0ZW5kU3RhdGljcyhkLCBiKSB7XG4gICAgX2V4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgICAgX19wcm90b19fOiBbXVxuICAgIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZC5fX3Byb3RvX18gPSBiO1xuICAgIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikge1xuICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgfTsgLy8gVWdseSBoYWNrIHRvIHJlc29sdmUgIzUwMiBhbmQgaW5oZXJpdCBidWlsdCBpbiBNYXAgLyBTZXRcblxuXG4gIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gICAgX2V4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgICBmdW5jdGlvbiBfXygpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICAgIH1cblxuICAgIGQucHJvdG90eXBlID0gKCAvLyBAdHMtaWdub3JlXG4gICAgX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfVxuXG4gIHZhciBEcmFmdE1hcCA9IGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRHJhZnRNYXAsIF9zdXBlcik7IC8vIENyZWF0ZSBjbGFzcyBtYW51YWxseSwgY2F1c2UgIzUwMlxuXG5cbiAgICBmdW5jdGlvbiBEcmFmdE1hcCh0YXJnZXQsIHBhcmVudCkge1xuICAgICAgdGhpc1tEUkFGVF9TVEFURV0gPSB7XG4gICAgICAgIHR5cGVfOiAyXG4gICAgICAgIC8qIE1hcCAqL1xuICAgICAgICAsXG4gICAgICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAgICAgc2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG4gICAgICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgICAgICBjb3B5XzogdW5kZWZpbmVkLFxuICAgICAgICBhc3NpZ25lZF86IHVuZGVmaW5lZCxcbiAgICAgICAgYmFzZV86IHRhcmdldCxcbiAgICAgICAgZHJhZnRfOiB0aGlzLFxuICAgICAgICBpc01hbnVhbF86IGZhbHNlLFxuICAgICAgICByZXZva2VkXzogZmFsc2VcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgcCA9IERyYWZ0TWFwLnByb3RvdHlwZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJzaXplXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5zaXplO1xuICAgICAgfSAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIC8vIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXG4gICAgfSk7XG5cbiAgICBwLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmhhcyhrZXkpO1xuICAgIH07XG5cbiAgICBwLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG5cbiAgICAgIGlmICghbGF0ZXN0KHN0YXRlKS5oYXMoa2V5KSB8fCBsYXRlc3Qoc3RhdGUpLmdldChrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIHRydWUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHAuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuXG4gICAgICBpZiAoc3RhdGUuYmFzZV8uaGFzKGtleSkpIHtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5kZWxldGUoa2V5KTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUuY29weV8uZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgcC5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcblxuICAgICAgaWYgKGxhdGVzdChzdGF0ZSkuc2l6ZSkge1xuICAgICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfID0gbmV3IE1hcCgpO1xuICAgICAgICBlYWNoKHN0YXRlLmJhc2VfLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHAuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYiwgdGhpc0FyZykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBsYXRlc3Qoc3RhdGUpLmZvckVhY2goZnVuY3Rpb24gKF92YWx1ZSwga2V5LCBfbWFwKSB7XG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgX3RoaXMuZ2V0KGtleSksIGtleSwgX3RoaXMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHAuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgdmFyIHZhbHVlID0gbGF0ZXN0KHN0YXRlKS5nZXQoa2V5KTtcblxuICAgICAgaWYgKHN0YXRlLmZpbmFsaXplZF8gfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gc3RhdGUuYmFzZV8uZ2V0KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlOyAvLyBlaXRoZXIgYWxyZWFkeSBkcmFmdGVkIG9yIHJlYXNzaWduZWRcbiAgICAgIH0gLy8gZGVzcGl0ZSB3aGF0IGl0IGxvb2tzLCB0aGlzIGNyZWF0ZXMgYSBkcmFmdCBvbmx5IG9uY2UsIHNlZSBhYm92ZSBjb25kaXRpb25cblxuXG4gICAgICB2YXIgZHJhZnQgPSBjcmVhdGVQcm94eShzdGF0ZS5zY29wZV8uaW1tZXJfLCB2YWx1ZSwgc3RhdGUpO1xuICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgc3RhdGUuY29weV8uc2V0KGtleSwgZHJhZnQpO1xuICAgICAgcmV0dXJuIGRyYWZ0O1xuICAgIH07XG5cbiAgICBwLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5rZXlzKCk7XG4gICAgfTtcblxuICAgIHAudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXMsXG4gICAgICAgICAgX3JlZjtcblxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5rZXlzKCk7XG4gICAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi52YWx1ZXMoKTtcbiAgICAgIH0sIF9yZWYubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciByID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgICAgIGlmIChyLmRvbmUpIHJldHVybiByO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IF90aGlzMi5nZXQoci52YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0sIF9yZWY7XG4gICAgfTtcblxuICAgIHAuZW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzLFxuICAgICAgICAgIF9yZWYyO1xuXG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcbiAgICAgIHJldHVybiBfcmVmMiA9IHt9LCBfcmVmMltpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuZW50cmllcygpO1xuICAgICAgfSwgX3JlZjIubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciByID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgICAgIGlmIChyLmRvbmUpIHJldHVybiByO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IF90aGlzMy5nZXQoci52YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogW3IudmFsdWUsIHZhbHVlXVxuICAgICAgICB9O1xuICAgICAgfSwgX3JlZjI7XG4gICAgfTtcblxuICAgIHBbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRHJhZnRNYXA7XG4gIH0oTWFwKTtcblxuICBmdW5jdGlvbiBwcm94eU1hcF8odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIG5ldyBEcmFmdE1hcCh0YXJnZXQsIHBhcmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlTWFwQ29weShzdGF0ZSkge1xuICAgIGlmICghc3RhdGUuY29weV8pIHtcbiAgICAgIHN0YXRlLmFzc2lnbmVkXyA9IG5ldyBNYXAoKTtcbiAgICAgIHN0YXRlLmNvcHlfID0gbmV3IE1hcChzdGF0ZS5iYXNlXyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIERyYWZ0U2V0ID0gZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEcmFmdFNldCwgX3N1cGVyKTsgLy8gQ3JlYXRlIGNsYXNzIG1hbnVhbGx5LCBjYXVzZSAjNTAyXG5cblxuICAgIGZ1bmN0aW9uIERyYWZ0U2V0KHRhcmdldCwgcGFyZW50KSB7XG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcbiAgICAgICAgdHlwZV86IDNcbiAgICAgICAgLyogU2V0ICovXG4gICAgICAgICxcbiAgICAgICAgcGFyZW50XzogcGFyZW50LFxuICAgICAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAgICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgICAgIGNvcHlfOiB1bmRlZmluZWQsXG4gICAgICAgIGJhc2VfOiB0YXJnZXQsXG4gICAgICAgIGRyYWZ0XzogdGhpcyxcbiAgICAgICAgZHJhZnRzXzogbmV3IE1hcCgpLFxuICAgICAgICByZXZva2VkXzogZmFsc2UsXG4gICAgICAgIGlzTWFudWFsXzogZmFsc2VcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgcCA9IERyYWZ0U2V0LnByb3RvdHlwZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJzaXplXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5zaXplO1xuICAgICAgfSAvLyBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgfSk7XG5cbiAgICBwLmhhcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpOyAvLyBiaXQgb2YgdHJpY2tlcnkgaGVyZSwgdG8gYmUgYWJsZSB0byByZWNvZ25pemUgYm90aCB0aGUgdmFsdWUsIGFuZCB0aGUgZHJhZnQgb2YgaXRzIHZhbHVlXG5cbiAgICAgIGlmICghc3RhdGUuY29weV8pIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmJhc2VfLmhhcyh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5jb3B5Xy5oYXModmFsdWUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChzdGF0ZS5kcmFmdHNfLmhhcyh2YWx1ZSkgJiYgc3RhdGUuY29weV8uaGFzKHN0YXRlLmRyYWZ0c18uZ2V0KHZhbHVlKSkpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBwLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuXG4gICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuY29weV8uYWRkKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHAuZGVsZXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5Xy5kZWxldGUodmFsdWUpIHx8IChzdGF0ZS5kcmFmdHNfLmhhcyh2YWx1ZSkgPyBzdGF0ZS5jb3B5Xy5kZWxldGUoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKSA6XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZmFsc2UpO1xuICAgIH07XG5cbiAgICBwLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuXG4gICAgICBpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG4gICAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5jbGVhcigpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5Xy52YWx1ZXMoKTtcbiAgICB9O1xuXG4gICAgcC5lbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5Xy5lbnRyaWVzKCk7XG4gICAgfTtcblxuICAgIHAua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICAgIH07XG5cbiAgICBwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICAgIH07XG5cbiAgICBwLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNiLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLnZhbHVlcygpO1xuICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgcmVzdWx0LnZhbHVlLCB0aGlzKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRHJhZnRTZXQ7XG4gIH0oU2V0KTtcblxuICBmdW5jdGlvbiBwcm94eVNldF8odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIG5ldyBEcmFmdFNldCh0YXJnZXQsIHBhcmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlU2V0Q29weShzdGF0ZSkge1xuICAgIGlmICghc3RhdGUuY29weV8pIHtcbiAgICAgIC8vIGNyZWF0ZSBkcmFmdHMgZm9yIGFsbCBlbnRyaWVzIHRvIHByZXNlcnZlIGluc2VydGlvbiBvcmRlclxuICAgICAgc3RhdGUuY29weV8gPSBuZXcgU2V0KCk7XG4gICAgICBzdGF0ZS5iYXNlXy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICAgICAgdmFyIGRyYWZ0ID0gY3JlYXRlUHJveHkoc3RhdGUuc2NvcGVfLmltbWVyXywgdmFsdWUsIHN0YXRlKTtcbiAgICAgICAgICBzdGF0ZS5kcmFmdHNfLnNldCh2YWx1ZSwgZHJhZnQpO1xuICAgICAgICAgIHN0YXRlLmNvcHlfLmFkZChkcmFmdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUuY29weV8uYWRkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0VW5yZXZva2VkKHN0YXRlXG4gIC8qRVM1U3RhdGUgfCBNYXBTdGF0ZSB8IFNldFN0YXRlKi9cbiAgKSB7XG4gICAgaWYgKHN0YXRlLnJldm9rZWRfKSBkaWUoMywgSlNPTi5zdHJpbmdpZnkobGF0ZXN0KHN0YXRlKSkpO1xuICB9XG5cbiAgbG9hZFBsdWdpbihcIk1hcFNldFwiLCB7XG4gICAgcHJveHlNYXBfOiBwcm94eU1hcF8sXG4gICAgcHJveHlTZXRfOiBwcm94eVNldF9cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVuYWJsZUFsbFBsdWdpbnMoKSB7XG4gIGVuYWJsZUVTNSgpO1xuICBlbmFibGVNYXBTZXQoKTtcbiAgZW5hYmxlUGF0Y2hlcygpO1xufVxuXG52YXIgaW1tZXIgPVxuLyojX19QVVJFX18qL1xubmV3IEltbWVyKCk7XG4vKipcclxuICogVGhlIGBwcm9kdWNlYCBmdW5jdGlvbiB0YWtlcyBhIHZhbHVlIGFuZCBhIFwicmVjaXBlIGZ1bmN0aW9uXCIgKHdob3NlXHJcbiAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xyXG4gKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcclxuICogb25seSBldmVyIGFwcGxpZWQgdG8gYSBfX2NvcHlfXyBvZiB0aGUgYmFzZSBzdGF0ZS5cclxuICpcclxuICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XHJcbiAqIGZyb20gcGFzc2luZyB0aGUgcmVjaXBlIGZ1bmN0aW9uIGV2ZXJ5IHRpbWUuXHJcbiAqXHJcbiAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxyXG4gKiBjb25zaWRlcmVkIHVuY29weWFibGUuXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2R1Y2VyIC0gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHByb3h5IG9mIHRoZSBiYXNlIHN0YXRlIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB3aGljaCBjYW4gYmUgZnJlZWx5IG1vZGlmaWVkXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhdGNoTGlzdGVuZXIgLSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHRoZSBwYXRjaGVzIHByb2R1Y2VkIGhlcmVcclxuICogQHJldHVybnMge2FueX0gYSBuZXcgc3RhdGUsIG9yIHRoZSBpbml0aWFsIHN0YXRlIGlmIG5vdGhpbmcgd2FzIG1vZGlmaWVkXHJcbiAqL1xuXG52YXIgcHJvZHVjZSA9IGltbWVyLnByb2R1Y2U7XG4vKipcclxuICogTGlrZSBgcHJvZHVjZWAsIGJ1dCBgcHJvZHVjZVdpdGhQYXRjaGVzYCBhbHdheXMgcmV0dXJucyBhIHR1cGxlXHJcbiAqIFtuZXh0U3RhdGUsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzXSAoaW5zdGVhZCBvZiBqdXN0IHRoZSBuZXh0IHN0YXRlKVxyXG4gKi9cblxudmFyIHByb2R1Y2VXaXRoUGF0Y2hlcyA9XG4vKiNfX1BVUkVfXyovXG5pbW1lci5wcm9kdWNlV2l0aFBhdGNoZXMuYmluZChpbW1lcik7XG4vKipcclxuICogUGFzcyB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgZnJlZXplIGFsbCBjb3BpZXMgY3JlYXRlZCBieSBJbW1lci5cclxuICpcclxuICogQWx3YXlzIGZyZWV6ZSBieSBkZWZhdWx0LCBldmVuIGluIHByb2R1Y3Rpb24gbW9kZVxyXG4gKi9cblxudmFyIHNldEF1dG9GcmVlemUgPVxuLyojX19QVVJFX18qL1xuaW1tZXIuc2V0QXV0b0ZyZWV6ZS5iaW5kKGltbWVyKTtcbi8qKlxyXG4gKiBQYXNzIHRydWUgdG8gdXNlIHRoZSBFUzIwMTUgYFByb3h5YCBjbGFzcyB3aGVuIGNyZWF0aW5nIGRyYWZ0cywgd2hpY2ggaXNcclxuICogYWx3YXlzIGZhc3RlciB0aGFuIHVzaW5nIEVTNSBwcm94aWVzLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBmZWF0dXJlIGRldGVjdGlvbiBpcyB1c2VkLCBzbyBjYWxsaW5nIHRoaXMgaXMgcmFyZWx5IG5lY2Vzc2FyeS5cclxuICovXG5cbnZhciBzZXRVc2VQcm94aWVzID1cbi8qI19fUFVSRV9fKi9cbmltbWVyLnNldFVzZVByb3hpZXMuYmluZChpbW1lcik7XG4vKipcclxuICogQXBwbHkgYW4gYXJyYXkgb2YgSW1tZXIgcGF0Y2hlcyB0byB0aGUgZmlyc3QgYXJndW1lbnQuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBwcm9kdWNlciwgd2hpY2ggbWVhbnMgY29weS1vbi13cml0ZSBpcyBpbiBlZmZlY3QuXHJcbiAqL1xuXG52YXIgYXBwbHlQYXRjaGVzID1cbi8qI19fUFVSRV9fKi9cbmltbWVyLmFwcGx5UGF0Y2hlcy5iaW5kKGltbWVyKTtcbi8qKlxyXG4gKiBDcmVhdGUgYW4gSW1tZXIgZHJhZnQgZnJvbSB0aGUgZ2l2ZW4gYmFzZSBzdGF0ZSwgd2hpY2ggbWF5IGJlIGEgZHJhZnQgaXRzZWxmLlxyXG4gKiBUaGUgZHJhZnQgY2FuIGJlIG1vZGlmaWVkIHVudGlsIHlvdSBmaW5hbGl6ZSBpdCB3aXRoIHRoZSBgZmluaXNoRHJhZnRgIGZ1bmN0aW9uLlxyXG4gKi9cblxudmFyIGNyZWF0ZURyYWZ0ID1cbi8qI19fUFVSRV9fKi9cbmltbWVyLmNyZWF0ZURyYWZ0LmJpbmQoaW1tZXIpO1xuLyoqXHJcbiAqIEZpbmFsaXplIGFuIEltbWVyIGRyYWZ0IGZyb20gYSBgY3JlYXRlRHJhZnRgIGNhbGwsIHJldHVybmluZyB0aGUgYmFzZSBzdGF0ZVxyXG4gKiAoaWYgbm8gY2hhbmdlcyB3ZXJlIG1hZGUpIG9yIGEgbW9kaWZpZWQgY29weS4gVGhlIGRyYWZ0IG11c3QgKm5vdCogYmVcclxuICogbXV0YXRlZCBhZnRlcndhcmRzLlxyXG4gKlxyXG4gKiBQYXNzIGEgZnVuY3Rpb24gYXMgdGhlIDJuZCBhcmd1bWVudCB0byBnZW5lcmF0ZSBJbW1lciBwYXRjaGVzIGJhc2VkIG9uIHRoZVxyXG4gKiBjaGFuZ2VzIHRoYXQgd2VyZSBtYWRlLlxyXG4gKi9cblxudmFyIGZpbmlzaERyYWZ0ID1cbi8qI19fUFVSRV9fKi9cbmltbWVyLmZpbmlzaERyYWZ0LmJpbmQoaW1tZXIpO1xuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgYSBuby1vcCwgYnV0IGNhbiBiZSB1c2VkIHRvIGNhc3QgYW4gaW1tdXRhYmxlIHR5cGVcclxuICogdG8gYW4gZHJhZnQgdHlwZSBhbmQgbWFrZSBUeXBlU2NyaXB0IGhhcHB5XHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKi9cblxuZnVuY3Rpb24gY2FzdERyYWZ0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IGEgbm8tb3AsIGJ1dCBjYW4gYmUgdXNlZCB0byBjYXN0IGEgbXV0YWJsZSB0eXBlXHJcbiAqIHRvIGFuIGltbXV0YWJsZSB0eXBlIGFuZCBtYWtlIFR5cGVTY3JpcHQgaGFwcHlcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xuXG5mdW5jdGlvbiBjYXN0SW1tdXRhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0cy5JbW1lciA9IEltbWVyO1xuZXhwb3J0cy5hcHBseVBhdGNoZXMgPSBhcHBseVBhdGNoZXM7XG5leHBvcnRzLmNhc3REcmFmdCA9IGNhc3REcmFmdDtcbmV4cG9ydHMuY2FzdEltbXV0YWJsZSA9IGNhc3RJbW11dGFibGU7XG5leHBvcnRzLmNyZWF0ZURyYWZ0ID0gY3JlYXRlRHJhZnQ7XG5leHBvcnRzLmN1cnJlbnQgPSBjdXJyZW50O1xuZXhwb3J0cy5kZWZhdWx0ID0gcHJvZHVjZTtcbmV4cG9ydHMuZW5hYmxlQWxsUGx1Z2lucyA9IGVuYWJsZUFsbFBsdWdpbnM7XG5leHBvcnRzLmVuYWJsZUVTNSA9IGVuYWJsZUVTNTtcbmV4cG9ydHMuZW5hYmxlTWFwU2V0ID0gZW5hYmxlTWFwU2V0O1xuZXhwb3J0cy5lbmFibGVQYXRjaGVzID0gZW5hYmxlUGF0Y2hlcztcbmV4cG9ydHMuZmluaXNoRHJhZnQgPSBmaW5pc2hEcmFmdDtcbmV4cG9ydHMuZnJlZXplID0gZnJlZXplO1xuZXhwb3J0cy5pbW1lcmFibGUgPSBEUkFGVEFCTEU7XG5leHBvcnRzLmlzRHJhZnQgPSBpc0RyYWZ0O1xuZXhwb3J0cy5pc0RyYWZ0YWJsZSA9IGlzRHJhZnRhYmxlO1xuZXhwb3J0cy5ub3RoaW5nID0gTk9USElORztcbmV4cG9ydHMub3JpZ2luYWwgPSBvcmlnaW5hbDtcbmV4cG9ydHMucHJvZHVjZSA9IHByb2R1Y2U7XG5leHBvcnRzLnByb2R1Y2VXaXRoUGF0Y2hlcyA9IHByb2R1Y2VXaXRoUGF0Y2hlcztcbmV4cG9ydHMuc2V0QXV0b0ZyZWV6ZSA9IHNldEF1dG9GcmVlemU7XG5leHBvcnRzLnNldFVzZVByb3hpZXMgPSBzZXRVc2VQcm94aWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1tZXIuY2pzLmRldmVsb3BtZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/immer/dist/immer.cjs.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/immer/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/immer/dist/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./immer.cjs.development.js */ \"(ssr)/./node_modules/immer/dist/immer.cjs.development.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQ1k7O0FBRVosSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGtJQUFzRDtBQUN4RCIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW4tcmVzdW1lLy4vbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvaW5kZXguanM/OTRhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbid1c2Ugc3RyaWN0J1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaW1tZXIuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbW1lci5janMuZGV2ZWxvcG1lbnQuanMnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/immer/dist/index.js\n");

/***/ })

};
;